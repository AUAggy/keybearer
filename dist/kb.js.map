{
  "version": 3,
  "sources": ["../src/kb.js", "../node_modules/@noble/ciphers/src/utils.ts", "../node_modules/@noble/ciphers/src/_arx.ts", "../node_modules/@noble/ciphers/src/_poly1305.ts", "../node_modules/@noble/ciphers/src/chacha.ts", "../node_modules/@noble/hashes/src/utils.ts", "../node_modules/@noble/hashes/src/hmac.ts", "../node_modules/@noble/hashes/src/pbkdf2.ts", "../node_modules/@noble/hashes/src/_md.ts", "../node_modules/@noble/hashes/src/sha2.ts", "../node_modules/@noble/hashes/src/sha256.ts", "../src/kb-noble.js", "../src/kb-legacy.js"],
  "sourcesContent": ["/**\n * Keybearer v2 - Client-side Shamir's Secret Sharing file encryption\n *\n * Migration to Noble cryptography libraries (@noble/ciphers, @noble/hashes)\n * Maintains backward compatibility with SJCL-encrypted files (v1)\n */\n\nimport * as noble from './kb-noble.js';\nimport * as legacy from './kb-legacy.js';\n\n// Global keybearer object (IIFE export for browser compatibility)\nconst keybearer = {\n  // Public settings\n  salt_length: 16, // in bytes (changed from SJCL words to bytes)\n  aes_key_strength: 32, // in bytes (256-bit key)\n  aes_cipher_mode: 'chacha20poly1305', // v2 default (v1 was 'ccm')\n  pbkdf2_iterations: 50000,\n\n  // Private state\n  _badngramlist: [],\n  _salt: null,\n  _plaintext: null, // Uint8Array of file to be encrypted\n  _cipherobj: null, // parsed encrypted data object\n  _passwords: [],\n  _keys: [], // Derived keys (Uint8Array arrays for v2, bitArrays for v1 compat)\n  _master: null, // Master encryption key\n  _filename: null,\n  _filetype: null,\n  _nPasswords: null,\n  _nToUnlock: null,\n  _lastMetadata: null,\n  _wordlist: [],\n\n  /**\n   * Load wordlist from URL\n   */\n  loadWordlist: function(url, field, callback) {\n    const startTime = Date.now();\n    const txtFile = new XMLHttpRequest();\n    txtFile.open('GET', url, true);\n    txtFile.onreadystatechange = function() {\n      if (txtFile.readyState === 4 && txtFile.status === 200) {\n        keybearer[field] = txtFile.responseText.split('\\n');\n        const endTime = Date.now();\n        // No need to seed RNG - crypto.getRandomValues() is always ready\n        callback();\n      }\n    };\n    txtFile.send();\n  },\n\n  /**\n   * Generate password from wordlist\n   */\n  makePassword: function(length) {\n    const pwd = [];\n    const selections = noble.randomIntegers(keybearer._wordlist.length, length);\n    for (let i = 0; i < length; i++) {\n      pwd[i] = keybearer._wordlist[selections[i]];\n    }\n\n    // Ensure no bad n-grams\n    const joined = pwd.join(' ');\n    for (let i = 0; i < keybearer._badngramlist.length; i++) {\n      if (joined.indexOf(keybearer._badngramlist[i]) !== -1) {\n        return keybearer.makePassword(length);\n      }\n    }\n    return joined;\n  },\n\n  /**\n   * Generate array of random integers\n   */\n  randto: function(end, num) {\n    return noble.randomIntegers(end, num);\n  },\n\n  /**\n   * Normalize string (trim and collapse whitespace)\n   */\n  normalizeString: function(string) {\n    return string.replace(/\\s+/g, ' ').replace(/(^\\s|\\s$)/g, '');\n  },\n\n  /**\n   * Generate salt\n   */\n  makeSalt: function() {\n    keybearer._salt = noble.getRandomBytes(keybearer.salt_length);\n  },\n\n  /**\n   * Derive key from password using PBKDF2-SHA256\n   */\n  makeKeyFromPassword: function(password) {\n    // For legacy decryption, use SJCL if available and salt is bitArray\n    if (typeof sjcl !== 'undefined' && Array.isArray(keybearer._salt)) {\n      return legacy.deriveKeyLegacy(\n        password,\n        keybearer._salt,\n        keybearer.pbkdf2_iterations,\n        keybearer.aes_key_strength * 8 // Convert bytes to bits\n      );\n    }\n    // For v2, use Noble\n    return noble.deriveKeyFromPassword(\n      password,\n      keybearer._salt,\n      keybearer.pbkdf2_iterations,\n      keybearer.aes_key_strength\n    );\n  },\n\n  /**\n   * Generate all password combinations (n choose k)\n   */\n  makeCombinedPasswords: function(passwords, nToUnlock) {\n    keybearer._nPasswords = passwords.length;\n    keybearer._nToUnlock = nToUnlock;\n\n    const combine = function(passwords, output, prefix, levels_left, start) {\n      if (levels_left <= 0) {\n        output.push(prefix.replace(/ /, ''));\n      } else {\n        for (let i = start; i < passwords.length; i++) {\n          combine(passwords, output, [prefix, passwords[i]].join(' '), levels_left - 1, i + 1);\n        }\n      }\n    };\n\n    const combined = [];\n    for (let i = 0; i < passwords.length; i++) {\n      passwords[i] = keybearer.normalizeString(passwords[i]);\n    }\n    passwords.sort();\n    combine(passwords, combined, null, nToUnlock, 0);\n    return combined;\n  },\n\n  /**\n   * Generate all key combinations with progress callback\n   */\n  makeKeyCombinations: function(passwords, nToUnlock, callback) {\n    callback = callback || function(x) {};\n    keybearer._keys = [];\n    const combinations = keybearer.makeCombinedPasswords(passwords, nToUnlock);\n    callback(0);\n\n    for (let i = 0; i < combinations.length; i++) {\n      keybearer._keys.push(keybearer.makeKeyFromPassword(combinations[i]));\n      callback((i + 1) / combinations.length);\n    }\n    callback(1);\n    return keybearer._keys;\n  },\n\n  /**\n   * Generate master encryption key\n   */\n  makeAESKey: function() {\n    keybearer._master = noble.getRandomBytes(keybearer.aes_key_strength);\n  },\n\n  /**\n   * Create metadata object for encrypted file\n   */\n  makeMetadataObject: function() {\n    const nonce = noble.getRandomBytes(12); // ChaCha20-Poly1305 uses 96-bit nonce\n    return {\n      adata: '',\n      iter: keybearer.pbkdf2_iterations,\n      mode: keybearer.aes_cipher_mode,\n      cipher: 'chacha20',\n      ts: 128, // tag size (bits)\n      ks: keybearer.aes_key_strength * 8, // key size in bits\n      salt: keybearer._salt,\n      iv: nonce,\n      v: 2, // Version 2\n      ct: null,\n      fn: keybearer._filename,\n      ft: keybearer._filetype,\n      nkeys: keybearer._nPasswords,\n      nunlock: keybearer._nToUnlock\n    };\n  },\n\n  /**\n   * Decrypt master key from encrypted key list\n   */\n  decryptKeys: function() {\n    // Check if legacy format\n    if (typeof sjcl !== 'undefined' && legacy.isLegacyFormat(keybearer._cipherobj)) {\n      return keybearer.decryptKeysLegacy();\n    }\n\n    // V2 decryption using Noble\n    let success = false;\n    for (let i = 0; i < keybearer._keys.length; i++) {\n      for (let j = 0; j < keybearer._cipherobj.keys.length; j++) {\n        try {\n          const keyiv = keybearer._cipherobj.keys[j];\n          keybearer._master = noble.decryptChaCha20Poly1305(\n            keybearer._keys[i],\n            keyiv.key,\n            keyiv.iv,\n            new Uint8Array(0)\n          );\n          success = true;\n          break;\n        } catch (err) {\n          // This wasn't the right key, continue\n        }\n      }\n      if (success) break;\n    }\n    return success;\n  },\n\n  /**\n   * Decrypt master key using legacy SJCL (v1)\n   */\n  decryptKeysLegacy: function() {\n    let success = false;\n    for (let i = 0; i < keybearer._keys.length; i++) {\n      for (let j = 0; j < keybearer._cipherobj.keys.length; j++) {\n        const master = legacy.decryptKeyLegacy(\n          keybearer._cipherobj,\n          keybearer._keys[i],\n          keybearer._cipherobj.keys[j]\n        );\n        if (master) {\n          keybearer._master = master;\n          success = true;\n          break;\n        }\n      }\n      if (success) break;\n    }\n    return success;\n  },\n\n  /**\n   * Decrypt ciphertext\n   */\n  decryptCiphertext: function() {\n    // Check if legacy format\n    if (typeof sjcl !== 'undefined' && legacy.isLegacyFormat(keybearer._cipherobj)) {\n      keybearer._plaintext = legacy.decryptLegacy(keybearer._cipherobj, keybearer._master);\n    } else {\n      // V2 decryption using Noble\n      keybearer._plaintext = noble.decryptChaCha20Poly1305(\n        keybearer._master,\n        keybearer._cipherobj.ct,\n        keybearer._cipherobj.iv,\n        new Uint8Array(0)\n      );\n    }\n  },\n\n  /**\n   * Complete encryption process with passwords\n   */\n  encryptWithPasswords: function(passwords, nUnlock, callback) {\n    keybearer.makeKeyCombinations(passwords, nUnlock, callback);\n    keybearer.makeAESKey();\n    return keybearer.encryptPlaintext(keybearer._plaintext);\n  },\n\n  /**\n   * Encrypt plaintext (always uses v2 Noble crypto)\n   */\n  encryptPlaintext: function(pt) {\n    const p = keybearer.makeMetadataObject();\n    const ptxt = pt || keybearer._plaintext;\n    keybearer._lastMetadata = p;\n\n    // Encrypt file content with master key\n    const result = noble.encryptChaCha20Poly1305(keybearer._master, ptxt, p.iv);\n    p.ct = result.ciphertext;\n    p.iv = result.nonce;\n\n    keybearer._cipherobj = p;\n    keybearer.augmentWithEncryptedKeys(keybearer._cipherobj);\n    return keybearer.getCipherJSON();\n  },\n\n  /**\n   * Encrypt master key with all password combinations\n   */\n  augmentWithEncryptedKeys: function(obj) {\n    const encKeys = [];\n    for (let i = 0; i < keybearer._keys.length; i++) {\n      const nonce = noble.getRandomBytes(12);\n      const result = noble.encryptChaCha20Poly1305(\n        keybearer._keys[i],\n        keybearer._master,\n        nonce,\n        new Uint8Array(0)\n      );\n      encKeys.push({ iv: result.nonce, key: result.ciphertext });\n    }\n    obj.keys = encKeys;\n    keybearer.shuffle(obj.keys);\n  },\n\n  /**\n   * Fisher-Yates shuffle\n   */\n  shuffle: function(arr) {\n    let i = arr.length;\n    if (i === 0) return false;\n    while (--i) {\n      const j = keybearer.randto(i + 1, 1)[0];\n      const tempi = arr[i];\n      arr[i] = arr[j];\n      arr[j] = tempi;\n    }\n    return arr;\n  },\n\n  /**\n   * Set plaintext from ArrayBuffer\n   */\n  setPlaintext: function(data, fn, ft) {\n    keybearer._plaintext = new Uint8Array(data);\n    if (fn) keybearer.setFileName(fn);\n    if (ft) keybearer.setFileType(ft);\n    return true;\n  },\n\n  setFileName: function(fname) {\n    keybearer._filename = fname;\n    return keybearer._filename;\n  },\n\n  setFileType: function(ftype) {\n    keybearer._filetype = ftype;\n    return keybearer._filetype;\n  },\n\n  setPBKDF2Iterations: function(num) {\n    keybearer.pbkdf2_iterations = num;\n  },\n\n  setWordlist: function(wl) {\n    keybearer._wordlist = wl;\n  },\n\n  setBadNGramList: function(wl) {\n    keybearer._badngramlist = wl;\n  },\n\n  getFileName: function() {\n    return keybearer._filename;\n  },\n\n  getFileType: function() {\n    return keybearer._filetype;\n  },\n\n  getNPasswords: function() {\n    return keybearer._nPasswords;\n  },\n\n  getNPasswordsDecrypt: function() {\n    return keybearer._cipherobj.nkeys;\n  },\n\n  getNumToUnlock: function() {\n    return keybearer._nToUnlock;\n  },\n\n  getWordlist: function() {\n    return keybearer._wordlist;\n  },\n\n  getBadNGramList: function() {\n    return keybearer._badngramlist;\n  },\n\n  resetKeys: function() {\n    keybearer._keys = [];\n  },\n\n  isPlaintextReady: function() {\n    return keybearer._plaintext !== null;\n  },\n\n  isCipherObjectReady: function() {\n    return keybearer._cipherobj !== null;\n  },\n\n  /**\n   * Parse encrypted JSON and prepare for decryption\n   */\n  setCipherJSON: function(data) {\n    const obj = JSON.parse(data);\n\n    // Detect version\n    const isLegacy = legacy.isLegacyFormat(obj);\n\n    if (isLegacy) {\n      // V1 format - keep SJCL bitArrays\n      obj.salt = sjcl.codec.base64.toBits(obj.salt);\n      obj.iv = sjcl.codec.base64.toBits(obj.iv);\n      obj.ct = sjcl.codec.base64.toBits(obj.ct);\n      for (let i = 0; i < obj.keys.length; i++) {\n        obj.keys[i].iv = sjcl.codec.base64.toBits(obj.keys[i].iv);\n        obj.keys[i].key = sjcl.codec.base64.toBits(obj.keys[i].key);\n      }\n    } else {\n      // V2 format - use Uint8Array\n      obj.salt = noble.decodeBase64(obj.salt);\n      obj.iv = noble.decodeBase64(obj.iv);\n      obj.ct = noble.decodeBase64(obj.ct);\n      for (let i = 0; i < obj.keys.length; i++) {\n        obj.keys[i].iv = noble.decodeBase64(obj.keys[i].iv);\n        obj.keys[i].key = noble.decodeBase64(obj.keys[i].key);\n      }\n    }\n\n    // Set keybearer fields\n    keybearer._salt = obj.salt;\n    keybearer._nPasswords = obj.nkeys;\n    keybearer._nToUnlock = obj.nunlock;\n    keybearer.setFileName(obj.fn);\n    keybearer.setFileType(obj.ft);\n    keybearer.setPBKDF2Iterations(obj.iter);\n    keybearer._cipherobj = obj;\n  },\n\n  /**\n   * Export encrypted object as JSON\n   */\n  getCipherJSON: function() {\n    const obj = JSON.parse(JSON.stringify(keybearer._cipherobj));\n\n    // Base64 encode all binary fields\n    for (let i = 0; i < obj.keys.length; i++) {\n      obj.keys[i].iv = noble.encodeBase64(obj.keys[i].iv);\n      obj.keys[i].key = noble.encodeBase64(obj.keys[i].key);\n    }\n    obj.salt = noble.encodeBase64(obj.salt);\n    obj.iv = noble.encodeBase64(obj.iv);\n    obj.ct = noble.encodeBase64(obj.ct);\n\n    return JSON.stringify(obj);\n  },\n\n  /**\n   * Get plaintext as Uint8Array\n   */\n  getPlaintext: function() {\n    return keybearer._plaintext;\n  },\n\n  /**\n   * Augment object with properties from another\n   */\n  augment: function(toAug, augger) {\n    for (const k in augger) {\n      if (augger.hasOwnProperty(k)) {\n        toAug[k] = augger[k];\n      }\n    }\n  }\n};\n\n// Export for module systems and global scope\nif (typeof window !== 'undefined') {\n  window.keybearer = keybearer;\n}\n\nexport default keybearer;\n", "/**\n * Utilities for hex, bytes, CSPRNG.\n * @module\n */\n/*! noble-ciphers - MIT License (c) 2023 Paul Miller (paulmillr.com) */\n\n/** Checks if something is Uint8Array. Be careful: nodejs Buffer will return true. */\nexport function isBytes(a: unknown): a is Uint8Array {\n  return a instanceof Uint8Array || (ArrayBuffer.isView(a) && a.constructor.name === 'Uint8Array');\n}\n\n/** Asserts something is boolean. */\nexport function abool(b: boolean): void {\n  if (typeof b !== 'boolean') throw new Error(`boolean expected, not ${b}`);\n}\n\n/** Asserts something is positive integer. */\nexport function anumber(n: number): void {\n  if (!Number.isSafeInteger(n) || n < 0) throw new Error('positive integer expected, got ' + n);\n}\n\n/** Asserts something is Uint8Array. */\nexport function abytes(b: Uint8Array | undefined, ...lengths: number[]): void {\n  if (!isBytes(b)) throw new Error('Uint8Array expected');\n  if (lengths.length > 0 && !lengths.includes(b.length))\n    throw new Error('Uint8Array expected of length ' + lengths + ', got length=' + b.length);\n}\n\n/**\n * Asserts something is hash\n * TODO: remove\n * @deprecated\n */\nexport function ahash(h: IHash): void {\n  if (typeof h !== 'function' || typeof h.create !== 'function')\n    throw new Error('Hash should be wrapped by utils.createHasher');\n  anumber(h.outputLen);\n  anumber(h.blockLen);\n}\n\n/** Asserts a hash instance has not been destroyed / finished */\nexport function aexists(instance: any, checkFinished = true): void {\n  if (instance.destroyed) throw new Error('Hash instance has been destroyed');\n  if (checkFinished && instance.finished) throw new Error('Hash#digest() has already been called');\n}\n\n/** Asserts output is properly-sized byte array */\nexport function aoutput(out: any, instance: any): void {\n  abytes(out);\n  const min = instance.outputLen;\n  if (out.length < min) {\n    throw new Error('digestInto() expects output buffer of length at least ' + min);\n  }\n}\n\nexport type IHash = {\n  (data: string | Uint8Array): Uint8Array;\n  blockLen: number;\n  outputLen: number;\n  create: any;\n};\n\n/** Generic type encompassing 8/16/32-byte arrays - but not 64-byte. */\n// prettier-ignore\nexport type TypedArray = Int8Array | Uint8ClampedArray | Uint8Array |\n  Uint16Array | Int16Array | Uint32Array | Int32Array;\n\n/** Cast u8 / u16 / u32 to u8. */\nexport function u8(arr: TypedArray): Uint8Array {\n  return new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\n}\n\n/** Cast u8 / u16 / u32 to u32. */\nexport function u32(arr: TypedArray): Uint32Array {\n  return new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));\n}\n\n/** Zeroize a byte array. Warning: JS provides no guarantees. */\nexport function clean(...arrays: TypedArray[]): void {\n  for (let i = 0; i < arrays.length; i++) {\n    arrays[i].fill(0);\n  }\n}\n\n/** Create DataView of an array for easy byte-level manipulation. */\nexport function createView(arr: TypedArray): DataView {\n  return new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\n}\n\n/** Is current platform little-endian? Most are. Big-Endian platform: IBM */\nexport const isLE: boolean = /* @__PURE__ */ (() =>\n  new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44)();\n\n// Built-in hex conversion https://caniuse.com/mdn-javascript_builtins_uint8array_fromhex\nconst hasHexBuiltin: boolean = /* @__PURE__ */ (() =>\n  // @ts-ignore\n  typeof Uint8Array.from([]).toHex === 'function' && typeof Uint8Array.fromHex === 'function')();\n\n// Array where index 0xf0 (240) is mapped to string 'f0'\nconst hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) =>\n  i.toString(16).padStart(2, '0')\n);\n\n/**\n * Convert byte array to hex string. Uses built-in function, when available.\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */\nexport function bytesToHex(bytes: Uint8Array): string {\n  abytes(bytes);\n  // @ts-ignore\n  if (hasHexBuiltin) return bytes.toHex();\n  // pre-caching improves the speed 6x\n  let hex = '';\n  for (let i = 0; i < bytes.length; i++) {\n    hex += hexes[bytes[i]];\n  }\n  return hex;\n}\n\n// We use optimized technique to convert hex string to byte array\nconst asciis = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 } as const;\nfunction asciiToBase16(ch: number): number | undefined {\n  if (ch >= asciis._0 && ch <= asciis._9) return ch - asciis._0; // '2' => 50-48\n  if (ch >= asciis.A && ch <= asciis.F) return ch - (asciis.A - 10); // 'B' => 66-(65-10)\n  if (ch >= asciis.a && ch <= asciis.f) return ch - (asciis.a - 10); // 'b' => 98-(97-10)\n  return;\n}\n\n/**\n * Convert hex string to byte array. Uses built-in function, when available.\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */\nexport function hexToBytes(hex: string): Uint8Array {\n  if (typeof hex !== 'string') throw new Error('hex string expected, got ' + typeof hex);\n  // @ts-ignore\n  if (hasHexBuiltin) return Uint8Array.fromHex(hex);\n  const hl = hex.length;\n  const al = hl / 2;\n  if (hl % 2) throw new Error('hex string expected, got unpadded hex of length ' + hl);\n  const array = new Uint8Array(al);\n  for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {\n    const n1 = asciiToBase16(hex.charCodeAt(hi));\n    const n2 = asciiToBase16(hex.charCodeAt(hi + 1));\n    if (n1 === undefined || n2 === undefined) {\n      const char = hex[hi] + hex[hi + 1];\n      throw new Error('hex string expected, got non-hex character \"' + char + '\" at index ' + hi);\n    }\n    array[ai] = n1 * 16 + n2; // multiply first octet, e.g. 'a3' => 10*16+3 => 160 + 3 => 163\n  }\n  return array;\n}\n\n// Used in micro\nexport function hexToNumber(hex: string): bigint {\n  if (typeof hex !== 'string') throw new Error('hex string expected, got ' + typeof hex);\n  return BigInt(hex === '' ? '0' : '0x' + hex); // Big Endian\n}\n\n// Used in ff1\n// BE: Big Endian, LE: Little Endian\nexport function bytesToNumberBE(bytes: Uint8Array): bigint {\n  return hexToNumber(bytesToHex(bytes));\n}\n\n// Used in micro, ff1\nexport function numberToBytesBE(n: number | bigint, len: number): Uint8Array {\n  return hexToBytes(n.toString(16).padStart(len * 2, '0'));\n}\n\n// TODO: remove\n// There is no setImmediate in browser and setTimeout is slow.\n// call of async fn will return Promise, which will be fullfiled only on\n// next scheduler queue processing step and this is exactly what we need.\nexport const nextTick = async (): Promise<void> => {};\n\n// Global symbols, but ts doesn't see them: https://github.com/microsoft/TypeScript/issues/31535\ndeclare const TextEncoder: any;\ndeclare const TextDecoder: any;\n\n/**\n * Converts string to bytes using UTF8 encoding.\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */\nexport function utf8ToBytes(str: string): Uint8Array {\n  if (typeof str !== 'string') throw new Error('string expected');\n  return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n\n/**\n * Converts bytes to string using UTF8 encoding.\n * @example bytesToUtf8(new Uint8Array([97, 98, 99])) // 'abc'\n */\nexport function bytesToUtf8(bytes: Uint8Array): string {\n  return new TextDecoder().decode(bytes);\n}\n\n// TODO: remove\nexport type Input = Uint8Array | string;\n/**\n * Normalizes (non-hex) string or Uint8Array to Uint8Array.\n * Warning: when Uint8Array is passed, it would NOT get copied.\n * Keep in mind for future mutable operations.\n */\nexport function toBytes(data: string | Uint8Array): Uint8Array {\n  if (typeof data === 'string') data = utf8ToBytes(data);\n  else if (isBytes(data)) data = copyBytes(data);\n  else throw new Error('Uint8Array expected, got ' + typeof data);\n  return data;\n}\n\n/**\n * Checks if two U8A use same underlying buffer and overlaps.\n * This is invalid and can corrupt data.\n */\nexport function overlapBytes(a: Uint8Array, b: Uint8Array): boolean {\n  return (\n    a.buffer === b.buffer && // best we can do, may fail with an obscure Proxy\n    a.byteOffset < b.byteOffset + b.byteLength && // a starts before b end\n    b.byteOffset < a.byteOffset + a.byteLength // b starts before a end\n  );\n}\n\n/**\n * If input and output overlap and input starts before output, we will overwrite end of input before\n * we start processing it, so this is not supported for most ciphers (except chacha/salse, which designed with this)\n */\nexport function complexOverlapBytes(input: Uint8Array, output: Uint8Array): void {\n  // This is very cursed. It works somehow, but I'm completely unsure,\n  // reasoning about overlapping aligned windows is very hard.\n  if (overlapBytes(input, output) && input.byteOffset < output.byteOffset)\n    throw new Error('complex overlap of input and output is not supported');\n}\n\n/**\n * Copies several Uint8Arrays into one.\n */\nexport function concatBytes(...arrays: Uint8Array[]): Uint8Array {\n  let sum = 0;\n  for (let i = 0; i < arrays.length; i++) {\n    const a = arrays[i];\n    abytes(a);\n    sum += a.length;\n  }\n  const res = new Uint8Array(sum);\n  for (let i = 0, pad = 0; i < arrays.length; i++) {\n    const a = arrays[i];\n    res.set(a, pad);\n    pad += a.length;\n  }\n  return res;\n}\n\n// Used in ARX only\ntype EmptyObj = {};\nexport function checkOpts<T1 extends EmptyObj, T2 extends EmptyObj>(\n  defaults: T1,\n  opts: T2\n): T1 & T2 {\n  if (opts == null || typeof opts !== 'object') throw new Error('options must be defined');\n  const merged = Object.assign(defaults, opts);\n  return merged as T1 & T2;\n}\n\n/** Compares 2 uint8array-s in kinda constant time. */\nexport function equalBytes(a: Uint8Array, b: Uint8Array): boolean {\n  if (a.length !== b.length) return false;\n  let diff = 0;\n  for (let i = 0; i < a.length; i++) diff |= a[i] ^ b[i];\n  return diff === 0;\n}\n\n// TODO: remove\n/** For runtime check if class implements interface. */\nexport abstract class Hash<T extends Hash<T>> {\n  abstract blockLen: number; // Bytes per block\n  abstract outputLen: number; // Bytes in output\n  abstract update(buf: string | Uint8Array): this;\n  // Writes digest into buf\n  abstract digestInto(buf: Uint8Array): void;\n  abstract digest(): Uint8Array;\n  /**\n   * Resets internal state. Makes Hash instance unusable.\n   * Reset is impossible for keyed hashes if key is consumed into state. If digest is not consumed\n   * by user, they will need to manually call `destroy()` when zeroing is necessary.\n   */\n  abstract destroy(): void;\n}\n\n// This will allow to re-use with composable things like packed & base encoders\n// Also, we probably can make tags composable\n\n/** Sync cipher: takes byte array and returns byte array. */\nexport type Cipher = {\n  encrypt(plaintext: Uint8Array): Uint8Array;\n  decrypt(ciphertext: Uint8Array): Uint8Array;\n};\n\n/** Async cipher e.g. from built-in WebCrypto. */\nexport type AsyncCipher = {\n  encrypt(plaintext: Uint8Array): Promise<Uint8Array>;\n  decrypt(ciphertext: Uint8Array): Promise<Uint8Array>;\n};\n\n/** Cipher with `output` argument which can optimize by doing 1 less allocation. */\nexport type CipherWithOutput = Cipher & {\n  encrypt(plaintext: Uint8Array, output?: Uint8Array): Uint8Array;\n  decrypt(ciphertext: Uint8Array, output?: Uint8Array): Uint8Array;\n};\n\n/**\n * Params are outside of return type, so it is accessible before calling constructor.\n * If function support multiple nonceLength's, we return the best one.\n */\nexport type CipherParams = {\n  blockSize: number;\n  nonceLength?: number;\n  tagLength?: number;\n  varSizeNonce?: boolean;\n};\n/** ARX cipher, like salsa or chacha. */\nexport type ARXCipher = ((\n  key: Uint8Array,\n  nonce: Uint8Array,\n  AAD?: Uint8Array\n) => CipherWithOutput) & {\n  blockSize: number;\n  nonceLength: number;\n  tagLength: number;\n};\nexport type CipherCons<T extends any[]> = (key: Uint8Array, ...args: T) => Cipher;\n/**\n * Wraps a cipher: validates args, ensures encrypt() can only be called once.\n * @__NO_SIDE_EFFECTS__\n */\nexport const wrapCipher = <C extends CipherCons<any>, P extends CipherParams>(\n  params: P,\n  constructor: C\n): C & P => {\n  function wrappedCipher(key: Uint8Array, ...args: any[]): CipherWithOutput {\n    // Validate key\n    abytes(key);\n\n    // Big-Endian hardware is rare. Just in case someone still decides to run ciphers:\n    if (!isLE) throw new Error('Non little-endian hardware is not yet supported');\n\n    // Validate nonce if nonceLength is present\n    if (params.nonceLength !== undefined) {\n      const nonce = args[0];\n      if (!nonce) throw new Error('nonce / iv required');\n      if (params.varSizeNonce) abytes(nonce);\n      else abytes(nonce, params.nonceLength);\n    }\n\n    // Validate AAD if tagLength present\n    const tagl = params.tagLength;\n    if (tagl && args[1] !== undefined) {\n      abytes(args[1]);\n    }\n\n    const cipher = constructor(key, ...args);\n    const checkOutput = (fnLength: number, output?: Uint8Array) => {\n      if (output !== undefined) {\n        if (fnLength !== 2) throw new Error('cipher output not supported');\n        abytes(output);\n      }\n    };\n    // Create wrapped cipher with validation and single-use encryption\n    let called = false;\n    const wrCipher = {\n      encrypt(data: Uint8Array, output?: Uint8Array) {\n        if (called) throw new Error('cannot encrypt() twice with same key + nonce');\n        called = true;\n        abytes(data);\n        checkOutput(cipher.encrypt.length, output);\n        return (cipher as CipherWithOutput).encrypt(data, output);\n      },\n      decrypt(data: Uint8Array, output?: Uint8Array) {\n        abytes(data);\n        if (tagl && data.length < tagl)\n          throw new Error('invalid ciphertext length: smaller than tagLength=' + tagl);\n        checkOutput(cipher.decrypt.length, output);\n        return (cipher as CipherWithOutput).decrypt(data, output);\n      },\n    };\n\n    return wrCipher;\n  }\n\n  Object.assign(wrappedCipher, params);\n  return wrappedCipher as C & P;\n};\n\n/** Represents salsa / chacha stream. */\nexport type XorStream = (\n  key: Uint8Array,\n  nonce: Uint8Array,\n  data: Uint8Array,\n  output?: Uint8Array,\n  counter?: number\n) => Uint8Array;\n\n/**\n * By default, returns u8a of length.\n * When out is available, it checks it for validity and uses it.\n */\nexport function getOutput(\n  expectedLength: number,\n  out?: Uint8Array,\n  onlyAligned = true\n): Uint8Array {\n  if (out === undefined) return new Uint8Array(expectedLength);\n  if (out.length !== expectedLength)\n    throw new Error('invalid output length, expected ' + expectedLength + ', got: ' + out.length);\n  if (onlyAligned && !isAligned32(out)) throw new Error('invalid output, must be aligned');\n  return out;\n}\n\n/** Polyfill for Safari 14. */\nexport function setBigUint64(\n  view: DataView,\n  byteOffset: number,\n  value: bigint,\n  isLE: boolean\n): void {\n  if (typeof view.setBigUint64 === 'function') return view.setBigUint64(byteOffset, value, isLE);\n  const _32n = BigInt(32);\n  const _u32_max = BigInt(0xffffffff);\n  const wh = Number((value >> _32n) & _u32_max);\n  const wl = Number(value & _u32_max);\n  const h = isLE ? 4 : 0;\n  const l = isLE ? 0 : 4;\n  view.setUint32(byteOffset + h, wh, isLE);\n  view.setUint32(byteOffset + l, wl, isLE);\n}\n\nexport function u64Lengths(dataLength: number, aadLength: number, isLE: boolean): Uint8Array {\n  abool(isLE);\n  const num = new Uint8Array(16);\n  const view = createView(num);\n  setBigUint64(view, 0, BigInt(aadLength), isLE);\n  setBigUint64(view, 8, BigInt(dataLength), isLE);\n  return num;\n}\n\n// Is byte array aligned to 4 byte offset (u32)?\nexport function isAligned32(bytes: Uint8Array): boolean {\n  return bytes.byteOffset % 4 === 0;\n}\n\n// copy bytes to new u8a (aligned). Because Buffer.slice is broken.\nexport function copyBytes(bytes: Uint8Array): Uint8Array {\n  return Uint8Array.from(bytes);\n}\n", "/**\n * Basic utils for ARX (add-rotate-xor) salsa and chacha ciphers.\n\nRFC8439 requires multi-step cipher stream, where\nauthKey starts with counter: 0, actual msg with counter: 1.\n\nFor this, we need a way to re-use nonce / counter:\n\n    const counter = new Uint8Array(4);\n    chacha(..., counter, ...); // counter is now 1\n    chacha(..., counter, ...); // counter is now 2\n\nThis is complicated:\n\n- 32-bit counters are enough, no need for 64-bit: max ArrayBuffer size in JS is 4GB\n- Original papers don't allow mutating counters\n- Counter overflow is undefined [^1]\n- Idea A: allow providing (nonce | counter) instead of just nonce, re-use it\n- Caveat: Cannot be re-used through all cases:\n- * chacha has (counter | nonce)\n- * xchacha has (nonce16 | counter | nonce16)\n- Idea B: separate nonce / counter and provide separate API for counter re-use\n- Caveat: there are different counter sizes depending on an algorithm.\n- salsa & chacha also differ in structures of key & sigma:\n  salsa20:      s[0] | k(4) | s[1] | nonce(2) | ctr(2) | s[2] | k(4) | s[3]\n  chacha:       s(4) | k(8) | ctr(1) | nonce(3)\n  chacha20orig: s(4) | k(8) | ctr(2) | nonce(2)\n- Idea C: helper method such as `setSalsaState(key, nonce, sigma, data)`\n- Caveat: we can't re-use counter array\n\nxchacha [^2] uses the subkey and remaining 8 byte nonce with ChaCha20 as normal\n(prefixed by 4 NUL bytes, since [RFC8439] specifies a 12-byte nonce).\n\n[^1]: https://mailarchive.ietf.org/arch/msg/cfrg/gsOnTJzcbgG6OqD8Sc0GO5aR_tU/\n[^2]: https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-xchacha#appendix-A.2\n\n * @module\n */\n// prettier-ignore\nimport {\n  type XorStream, abool, abytes, anumber, checkOpts, clean, copyBytes, u32\n} from './utils.ts';\n\n// We can't make top-level var depend on utils.utf8ToBytes\n// because it's not present in all envs. Creating a similar fn here\nconst _utf8ToBytes = (str: string) => Uint8Array.from(str.split('').map((c) => c.charCodeAt(0)));\nconst sigma16 = _utf8ToBytes('expand 16-byte k');\nconst sigma32 = _utf8ToBytes('expand 32-byte k');\nconst sigma16_32 = u32(sigma16);\nconst sigma32_32 = u32(sigma32);\n\nexport function rotl(a: number, b: number): number {\n  return (a << b) | (a >>> (32 - b));\n}\n\n/** Ciphers must use u32 for efficiency. */\nexport type CipherCoreFn = (\n  sigma: Uint32Array,\n  key: Uint32Array,\n  nonce: Uint32Array,\n  output: Uint32Array,\n  counter: number,\n  rounds?: number\n) => void;\n\n/** Method which extends key + short nonce into larger nonce / diff key. */\nexport type ExtendNonceFn = (\n  sigma: Uint32Array,\n  key: Uint32Array,\n  input: Uint32Array,\n  output: Uint32Array\n) => void;\n\n/** ARX cipher options.\n * * `allowShortKeys` for 16-byte keys\n * * `counterLength` in bytes\n * * `counterRight`: right: `nonce|counter`; left: `counter|nonce`\n * */\nexport type CipherOpts = {\n  allowShortKeys?: boolean; // Original salsa / chacha allow 16-byte keys\n  extendNonceFn?: ExtendNonceFn;\n  counterLength?: number;\n  counterRight?: boolean;\n  rounds?: number;\n};\n\n// Is byte array aligned to 4 byte offset (u32)?\nfunction isAligned32(b: Uint8Array) {\n  return b.byteOffset % 4 === 0;\n}\n\n// Salsa and Chacha block length is always 512-bit\nconst BLOCK_LEN = 64;\nconst BLOCK_LEN32 = 16;\n\n// new Uint32Array([2**32])   // => Uint32Array(1) [ 0 ]\n// new Uint32Array([2**32-1]) // => Uint32Array(1) [ 4294967295 ]\nconst MAX_COUNTER = 2 ** 32 - 1;\n\nconst U32_EMPTY = new Uint32Array();\nfunction runCipher(\n  core: CipherCoreFn,\n  sigma: Uint32Array,\n  key: Uint32Array,\n  nonce: Uint32Array,\n  data: Uint8Array,\n  output: Uint8Array,\n  counter: number,\n  rounds: number\n): void {\n  const len = data.length;\n  const block = new Uint8Array(BLOCK_LEN);\n  const b32 = u32(block);\n  // Make sure that buffers aligned to 4 bytes\n  const isAligned = isAligned32(data) && isAligned32(output);\n  const d32 = isAligned ? u32(data) : U32_EMPTY;\n  const o32 = isAligned ? u32(output) : U32_EMPTY;\n  for (let pos = 0; pos < len; counter++) {\n    core(sigma, key, nonce, b32, counter, rounds);\n    if (counter >= MAX_COUNTER) throw new Error('arx: counter overflow');\n    const take = Math.min(BLOCK_LEN, len - pos);\n    // aligned to 4 bytes\n    if (isAligned && take === BLOCK_LEN) {\n      const pos32 = pos / 4;\n      if (pos % 4 !== 0) throw new Error('arx: invalid block position');\n      for (let j = 0, posj: number; j < BLOCK_LEN32; j++) {\n        posj = pos32 + j;\n        o32[posj] = d32[posj] ^ b32[j];\n      }\n      pos += BLOCK_LEN;\n      continue;\n    }\n    for (let j = 0, posj; j < take; j++) {\n      posj = pos + j;\n      output[posj] = data[posj] ^ block[j];\n    }\n    pos += take;\n  }\n}\n\n/** Creates ARX-like (ChaCha, Salsa) cipher stream from core function. */\nexport function createCipher(core: CipherCoreFn, opts: CipherOpts): XorStream {\n  const { allowShortKeys, extendNonceFn, counterLength, counterRight, rounds } = checkOpts(\n    { allowShortKeys: false, counterLength: 8, counterRight: false, rounds: 20 },\n    opts\n  );\n  if (typeof core !== 'function') throw new Error('core must be a function');\n  anumber(counterLength);\n  anumber(rounds);\n  abool(counterRight);\n  abool(allowShortKeys);\n  return (\n    key: Uint8Array,\n    nonce: Uint8Array,\n    data: Uint8Array,\n    output?: Uint8Array,\n    counter = 0\n  ): Uint8Array => {\n    abytes(key);\n    abytes(nonce);\n    abytes(data);\n    const len = data.length;\n    if (output === undefined) output = new Uint8Array(len);\n    abytes(output);\n    anumber(counter);\n    if (counter < 0 || counter >= MAX_COUNTER) throw new Error('arx: counter overflow');\n    if (output.length < len)\n      throw new Error(`arx: output (${output.length}) is shorter than data (${len})`);\n    const toClean = [];\n\n    // Key & sigma\n    // key=16 -> sigma16, k=key|key\n    // key=32 -> sigma32, k=key\n    let l = key.length;\n    let k: Uint8Array;\n    let sigma: Uint32Array;\n    if (l === 32) {\n      toClean.push((k = copyBytes(key)));\n      sigma = sigma32_32;\n    } else if (l === 16 && allowShortKeys) {\n      k = new Uint8Array(32);\n      k.set(key);\n      k.set(key, 16);\n      sigma = sigma16_32;\n      toClean.push(k);\n    } else {\n      throw new Error(`arx: invalid 32-byte key, got length=${l}`);\n    }\n\n    // Nonce\n    // salsa20:      8   (8-byte counter)\n    // chacha20orig: 8   (8-byte counter)\n    // chacha20:     12  (4-byte counter)\n    // xsalsa20:     24  (16 -> hsalsa,  8 -> old nonce)\n    // xchacha20:    24  (16 -> hchacha, 8 -> old nonce)\n    // Align nonce to 4 bytes\n    if (!isAligned32(nonce)) toClean.push((nonce = copyBytes(nonce)));\n\n    const k32 = u32(k);\n    // hsalsa & hchacha: handle extended nonce\n    if (extendNonceFn) {\n      if (nonce.length !== 24) throw new Error(`arx: extended nonce must be 24 bytes`);\n      extendNonceFn(sigma, k32, u32(nonce.subarray(0, 16)), k32);\n      nonce = nonce.subarray(16);\n    }\n\n    // Handle nonce counter\n    const nonceNcLen = 16 - counterLength;\n    if (nonceNcLen !== nonce.length)\n      throw new Error(`arx: nonce must be ${nonceNcLen} or 16 bytes`);\n\n    // Pad counter when nonce is 64 bit\n    if (nonceNcLen !== 12) {\n      const nc = new Uint8Array(12);\n      nc.set(nonce, counterRight ? 0 : 12 - nonce.length);\n      nonce = nc;\n      toClean.push(nonce);\n    }\n    const n32 = u32(nonce);\n    runCipher(core, sigma, k32, n32, data, output, counter, rounds);\n    clean(...toClean);\n    return output;\n  };\n}\n", "/**\n * Poly1305 ([PDF](https://cr.yp.to/mac/poly1305-20050329.pdf),\n * [wiki](https://en.wikipedia.org/wiki/Poly1305))\n * is a fast and parallel secret-key message-authentication code suitable for\n * a wide variety of applications. It was standardized in\n * [RFC 8439](https://datatracker.ietf.org/doc/html/rfc8439) and is now used in TLS 1.3.\n *\n * Polynomial MACs are not perfect for every situation:\n * they lack Random Key Robustness: the MAC can be forged, and can't be used in PAKE schemes.\n * See [invisible salamanders attack](https://keymaterial.net/2020/09/07/invisible-salamanders-in-aes-gcm-siv/).\n * To combat invisible salamanders, `hash(key)` can be included in ciphertext,\n * however, this would violate ciphertext indistinguishability:\n * an attacker would know which key was used - so `HKDF(key, i)`\n * could be used instead.\n *\n * Check out [original website](https://cr.yp.to/mac.html).\n * @module\n */\nimport { Hash, type Input, abytes, aexists, aoutput, clean, toBytes } from './utils.ts';\n\n// Based on Public Domain poly1305-donna https://github.com/floodyberry/poly1305-donna\nconst u8to16 = (a: Uint8Array, i: number) => (a[i++] & 0xff) | ((a[i++] & 0xff) << 8);\nclass Poly1305 implements Hash<Poly1305> {\n  readonly blockLen = 16;\n  readonly outputLen = 16;\n  private buffer = new Uint8Array(16);\n  private r = new Uint16Array(10);\n  private h = new Uint16Array(10);\n  private pad = new Uint16Array(8);\n  private pos = 0;\n  protected finished = false;\n\n  constructor(key: Input) {\n    key = toBytes(key);\n    abytes(key, 32);\n    const t0 = u8to16(key, 0);\n    const t1 = u8to16(key, 2);\n    const t2 = u8to16(key, 4);\n    const t3 = u8to16(key, 6);\n    const t4 = u8to16(key, 8);\n    const t5 = u8to16(key, 10);\n    const t6 = u8to16(key, 12);\n    const t7 = u8to16(key, 14);\n\n    // https://github.com/floodyberry/poly1305-donna/blob/e6ad6e091d30d7f4ec2d4f978be1fcfcbce72781/poly1305-donna-16.h#L47\n    this.r[0] = t0 & 0x1fff;\n    this.r[1] = ((t0 >>> 13) | (t1 << 3)) & 0x1fff;\n    this.r[2] = ((t1 >>> 10) | (t2 << 6)) & 0x1f03;\n    this.r[3] = ((t2 >>> 7) | (t3 << 9)) & 0x1fff;\n    this.r[4] = ((t3 >>> 4) | (t4 << 12)) & 0x00ff;\n    this.r[5] = (t4 >>> 1) & 0x1ffe;\n    this.r[6] = ((t4 >>> 14) | (t5 << 2)) & 0x1fff;\n    this.r[7] = ((t5 >>> 11) | (t6 << 5)) & 0x1f81;\n    this.r[8] = ((t6 >>> 8) | (t7 << 8)) & 0x1fff;\n    this.r[9] = (t7 >>> 5) & 0x007f;\n    for (let i = 0; i < 8; i++) this.pad[i] = u8to16(key, 16 + 2 * i);\n  }\n\n  private process(data: Uint8Array, offset: number, isLast = false) {\n    const hibit = isLast ? 0 : 1 << 11;\n    const { h, r } = this;\n    const r0 = r[0];\n    const r1 = r[1];\n    const r2 = r[2];\n    const r3 = r[3];\n    const r4 = r[4];\n    const r5 = r[5];\n    const r6 = r[6];\n    const r7 = r[7];\n    const r8 = r[8];\n    const r9 = r[9];\n\n    const t0 = u8to16(data, offset + 0);\n    const t1 = u8to16(data, offset + 2);\n    const t2 = u8to16(data, offset + 4);\n    const t3 = u8to16(data, offset + 6);\n    const t4 = u8to16(data, offset + 8);\n    const t5 = u8to16(data, offset + 10);\n    const t6 = u8to16(data, offset + 12);\n    const t7 = u8to16(data, offset + 14);\n\n    let h0 = h[0] + (t0 & 0x1fff);\n    let h1 = h[1] + (((t0 >>> 13) | (t1 << 3)) & 0x1fff);\n    let h2 = h[2] + (((t1 >>> 10) | (t2 << 6)) & 0x1fff);\n    let h3 = h[3] + (((t2 >>> 7) | (t3 << 9)) & 0x1fff);\n    let h4 = h[4] + (((t3 >>> 4) | (t4 << 12)) & 0x1fff);\n    let h5 = h[5] + ((t4 >>> 1) & 0x1fff);\n    let h6 = h[6] + (((t4 >>> 14) | (t5 << 2)) & 0x1fff);\n    let h7 = h[7] + (((t5 >>> 11) | (t6 << 5)) & 0x1fff);\n    let h8 = h[8] + (((t6 >>> 8) | (t7 << 8)) & 0x1fff);\n    let h9 = h[9] + ((t7 >>> 5) | hibit);\n\n    let c = 0;\n\n    let d0 = c + h0 * r0 + h1 * (5 * r9) + h2 * (5 * r8) + h3 * (5 * r7) + h4 * (5 * r6);\n    c = d0 >>> 13;\n    d0 &= 0x1fff;\n    d0 += h5 * (5 * r5) + h6 * (5 * r4) + h7 * (5 * r3) + h8 * (5 * r2) + h9 * (5 * r1);\n    c += d0 >>> 13;\n    d0 &= 0x1fff;\n\n    let d1 = c + h0 * r1 + h1 * r0 + h2 * (5 * r9) + h3 * (5 * r8) + h4 * (5 * r7);\n    c = d1 >>> 13;\n    d1 &= 0x1fff;\n    d1 += h5 * (5 * r6) + h6 * (5 * r5) + h7 * (5 * r4) + h8 * (5 * r3) + h9 * (5 * r2);\n    c += d1 >>> 13;\n    d1 &= 0x1fff;\n\n    let d2 = c + h0 * r2 + h1 * r1 + h2 * r0 + h3 * (5 * r9) + h4 * (5 * r8);\n    c = d2 >>> 13;\n    d2 &= 0x1fff;\n    d2 += h5 * (5 * r7) + h6 * (5 * r6) + h7 * (5 * r5) + h8 * (5 * r4) + h9 * (5 * r3);\n    c += d2 >>> 13;\n    d2 &= 0x1fff;\n\n    let d3 = c + h0 * r3 + h1 * r2 + h2 * r1 + h3 * r0 + h4 * (5 * r9);\n    c = d3 >>> 13;\n    d3 &= 0x1fff;\n    d3 += h5 * (5 * r8) + h6 * (5 * r7) + h7 * (5 * r6) + h8 * (5 * r5) + h9 * (5 * r4);\n    c += d3 >>> 13;\n    d3 &= 0x1fff;\n\n    let d4 = c + h0 * r4 + h1 * r3 + h2 * r2 + h3 * r1 + h4 * r0;\n    c = d4 >>> 13;\n    d4 &= 0x1fff;\n    d4 += h5 * (5 * r9) + h6 * (5 * r8) + h7 * (5 * r7) + h8 * (5 * r6) + h9 * (5 * r5);\n    c += d4 >>> 13;\n    d4 &= 0x1fff;\n\n    let d5 = c + h0 * r5 + h1 * r4 + h2 * r3 + h3 * r2 + h4 * r1;\n    c = d5 >>> 13;\n    d5 &= 0x1fff;\n    d5 += h5 * r0 + h6 * (5 * r9) + h7 * (5 * r8) + h8 * (5 * r7) + h9 * (5 * r6);\n    c += d5 >>> 13;\n    d5 &= 0x1fff;\n\n    let d6 = c + h0 * r6 + h1 * r5 + h2 * r4 + h3 * r3 + h4 * r2;\n    c = d6 >>> 13;\n    d6 &= 0x1fff;\n    d6 += h5 * r1 + h6 * r0 + h7 * (5 * r9) + h8 * (5 * r8) + h9 * (5 * r7);\n    c += d6 >>> 13;\n    d6 &= 0x1fff;\n\n    let d7 = c + h0 * r7 + h1 * r6 + h2 * r5 + h3 * r4 + h4 * r3;\n    c = d7 >>> 13;\n    d7 &= 0x1fff;\n    d7 += h5 * r2 + h6 * r1 + h7 * r0 + h8 * (5 * r9) + h9 * (5 * r8);\n    c += d7 >>> 13;\n    d7 &= 0x1fff;\n\n    let d8 = c + h0 * r8 + h1 * r7 + h2 * r6 + h3 * r5 + h4 * r4;\n    c = d8 >>> 13;\n    d8 &= 0x1fff;\n    d8 += h5 * r3 + h6 * r2 + h7 * r1 + h8 * r0 + h9 * (5 * r9);\n    c += d8 >>> 13;\n    d8 &= 0x1fff;\n\n    let d9 = c + h0 * r9 + h1 * r8 + h2 * r7 + h3 * r6 + h4 * r5;\n    c = d9 >>> 13;\n    d9 &= 0x1fff;\n    d9 += h5 * r4 + h6 * r3 + h7 * r2 + h8 * r1 + h9 * r0;\n    c += d9 >>> 13;\n    d9 &= 0x1fff;\n\n    c = ((c << 2) + c) | 0;\n    c = (c + d0) | 0;\n    d0 = c & 0x1fff;\n    c = c >>> 13;\n    d1 += c;\n\n    h[0] = d0;\n    h[1] = d1;\n    h[2] = d2;\n    h[3] = d3;\n    h[4] = d4;\n    h[5] = d5;\n    h[6] = d6;\n    h[7] = d7;\n    h[8] = d8;\n    h[9] = d9;\n  }\n\n  private finalize() {\n    const { h, pad } = this;\n    const g = new Uint16Array(10);\n    let c = h[1] >>> 13;\n    h[1] &= 0x1fff;\n    for (let i = 2; i < 10; i++) {\n      h[i] += c;\n      c = h[i] >>> 13;\n      h[i] &= 0x1fff;\n    }\n    h[0] += c * 5;\n    c = h[0] >>> 13;\n    h[0] &= 0x1fff;\n    h[1] += c;\n    c = h[1] >>> 13;\n    h[1] &= 0x1fff;\n    h[2] += c;\n\n    g[0] = h[0] + 5;\n    c = g[0] >>> 13;\n    g[0] &= 0x1fff;\n    for (let i = 1; i < 10; i++) {\n      g[i] = h[i] + c;\n      c = g[i] >>> 13;\n      g[i] &= 0x1fff;\n    }\n    g[9] -= 1 << 13;\n\n    let mask = (c ^ 1) - 1;\n    for (let i = 0; i < 10; i++) g[i] &= mask;\n    mask = ~mask;\n    for (let i = 0; i < 10; i++) h[i] = (h[i] & mask) | g[i];\n    h[0] = (h[0] | (h[1] << 13)) & 0xffff;\n    h[1] = ((h[1] >>> 3) | (h[2] << 10)) & 0xffff;\n    h[2] = ((h[2] >>> 6) | (h[3] << 7)) & 0xffff;\n    h[3] = ((h[3] >>> 9) | (h[4] << 4)) & 0xffff;\n    h[4] = ((h[4] >>> 12) | (h[5] << 1) | (h[6] << 14)) & 0xffff;\n    h[5] = ((h[6] >>> 2) | (h[7] << 11)) & 0xffff;\n    h[6] = ((h[7] >>> 5) | (h[8] << 8)) & 0xffff;\n    h[7] = ((h[8] >>> 8) | (h[9] << 5)) & 0xffff;\n\n    let f = h[0] + pad[0];\n    h[0] = f & 0xffff;\n    for (let i = 1; i < 8; i++) {\n      f = (((h[i] + pad[i]) | 0) + (f >>> 16)) | 0;\n      h[i] = f & 0xffff;\n    }\n    clean(g);\n  }\n  update(data: Input): this {\n    aexists(this);\n    data = toBytes(data);\n    abytes(data);\n    const { buffer, blockLen } = this;\n    const len = data.length;\n\n    for (let pos = 0; pos < len; ) {\n      const take = Math.min(blockLen - this.pos, len - pos);\n      // Fast path: we have at least one block in input\n      if (take === blockLen) {\n        for (; blockLen <= len - pos; pos += blockLen) this.process(data, pos);\n        continue;\n      }\n      buffer.set(data.subarray(pos, pos + take), this.pos);\n      this.pos += take;\n      pos += take;\n      if (this.pos === blockLen) {\n        this.process(buffer, 0, false);\n        this.pos = 0;\n      }\n    }\n    return this;\n  }\n  destroy() {\n    clean(this.h, this.r, this.buffer, this.pad);\n  }\n  digestInto(out: Uint8Array) {\n    aexists(this);\n    aoutput(out, this);\n    this.finished = true;\n    const { buffer, h } = this;\n    let { pos } = this;\n    if (pos) {\n      buffer[pos++] = 1;\n      for (; pos < 16; pos++) buffer[pos] = 0;\n      this.process(buffer, 0, true);\n    }\n    this.finalize();\n    let opos = 0;\n    for (let i = 0; i < 8; i++) {\n      out[opos++] = h[i] >>> 0;\n      out[opos++] = h[i] >>> 8;\n    }\n    return out;\n  }\n  digest(): Uint8Array {\n    const { buffer, outputLen } = this;\n    this.digestInto(buffer);\n    const res = buffer.slice(0, outputLen);\n    this.destroy();\n    return res;\n  }\n}\n\nexport type CHash = ReturnType<typeof wrapConstructorWithKey>;\nexport function wrapConstructorWithKey<H extends Hash<H>>(\n  hashCons: (key: Input) => Hash<H>\n): {\n  (msg: Input, key: Input): Uint8Array;\n  outputLen: number;\n  blockLen: number;\n  create(key: Input): Hash<H>;\n} {\n  const hashC = (msg: Input, key: Input): Uint8Array => hashCons(key).update(toBytes(msg)).digest();\n  const tmp = hashCons(new Uint8Array(32));\n  hashC.outputLen = tmp.outputLen;\n  hashC.blockLen = tmp.blockLen;\n  hashC.create = (key: Input) => hashCons(key);\n  return hashC;\n}\n\n/** Poly1305 MAC from RFC 8439. */\nexport const poly1305: CHash = wrapConstructorWithKey((key) => new Poly1305(key));\n", "/**\n * [ChaCha20](https://cr.yp.to/chacha.html) stream cipher, released\n * in 2008. Developed after Salsa20, ChaCha aims to increase diffusion per round.\n * It was standardized in [RFC 8439](https://datatracker.ietf.org/doc/html/rfc8439) and\n * is now used in TLS 1.3.\n *\n * [XChaCha20](https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-xchacha)\n * extended-nonce variant is also provided. Similar to XSalsa, it's safe to use with\n * randomly-generated nonces.\n *\n * Check out [PDF](http://cr.yp.to/chacha/chacha-20080128.pdf) and\n * [wiki](https://en.wikipedia.org/wiki/Salsa20).\n * @module\n */\nimport { createCipher, rotl } from './_arx.ts';\nimport { poly1305 } from './_poly1305.ts';\nimport {\n  type ARXCipher,\n  type CipherWithOutput,\n  type XorStream,\n  clean,\n  equalBytes,\n  getOutput,\n  u64Lengths,\n  wrapCipher,\n} from './utils.ts';\n\n/**\n * ChaCha core function.\n */\n// prettier-ignore\nfunction chachaCore(\n  s: Uint32Array, k: Uint32Array, n: Uint32Array, out: Uint32Array, cnt: number, rounds = 20\n): void {\n  let y00 = s[0], y01 = s[1], y02 = s[2], y03 = s[3], // \"expa\"   \"nd 3\"  \"2-by\"  \"te k\"\n    y04 = k[0], y05 = k[1], y06 = k[2], y07 = k[3],   // Key      Key     Key     Key\n    y08 = k[4], y09 = k[5], y10 = k[6], y11 = k[7],   // Key      Key     Key     Key\n    y12 = cnt, y13 = n[0], y14 = n[1], y15 = n[2];    // Counter  Counter\tNonce   Nonce\n  // Save state to temporary variables\n  let x00 = y00, x01 = y01, x02 = y02, x03 = y03,\n      x04 = y04, x05 = y05, x06 = y06, x07 = y07,\n      x08 = y08, x09 = y09, x10 = y10, x11 = y11,\n      x12 = y12, x13 = y13, x14 = y14, x15 = y15;\n  for (let r = 0; r < rounds; r += 2) {\n    x00 = (x00 + x04) | 0; x12 = rotl(x12 ^ x00, 16);\n    x08 = (x08 + x12) | 0; x04 = rotl(x04 ^ x08, 12);\n    x00 = (x00 + x04) | 0; x12 = rotl(x12 ^ x00, 8);\n    x08 = (x08 + x12) | 0; x04 = rotl(x04 ^ x08, 7);\n\n    x01 = (x01 + x05) | 0; x13 = rotl(x13 ^ x01, 16);\n    x09 = (x09 + x13) | 0; x05 = rotl(x05 ^ x09, 12);\n    x01 = (x01 + x05) | 0; x13 = rotl(x13 ^ x01, 8);\n    x09 = (x09 + x13) | 0; x05 = rotl(x05 ^ x09, 7);\n\n    x02 = (x02 + x06) | 0; x14 = rotl(x14 ^ x02, 16);\n    x10 = (x10 + x14) | 0; x06 = rotl(x06 ^ x10, 12);\n    x02 = (x02 + x06) | 0; x14 = rotl(x14 ^ x02, 8);\n    x10 = (x10 + x14) | 0; x06 = rotl(x06 ^ x10, 7);\n\n    x03 = (x03 + x07) | 0; x15 = rotl(x15 ^ x03, 16);\n    x11 = (x11 + x15) | 0; x07 = rotl(x07 ^ x11, 12);\n    x03 = (x03 + x07) | 0; x15 = rotl(x15 ^ x03, 8)\n    x11 = (x11 + x15) | 0; x07 = rotl(x07 ^ x11, 7);\n\n    x00 = (x00 + x05) | 0; x15 = rotl(x15 ^ x00, 16);\n    x10 = (x10 + x15) | 0; x05 = rotl(x05 ^ x10, 12);\n    x00 = (x00 + x05) | 0; x15 = rotl(x15 ^ x00, 8);\n    x10 = (x10 + x15) | 0; x05 = rotl(x05 ^ x10, 7);\n\n    x01 = (x01 + x06) | 0; x12 = rotl(x12 ^ x01, 16);\n    x11 = (x11 + x12) | 0; x06 = rotl(x06 ^ x11, 12);\n    x01 = (x01 + x06) | 0; x12 = rotl(x12 ^ x01, 8);\n    x11 = (x11 + x12) | 0; x06 = rotl(x06 ^ x11, 7);\n\n    x02 = (x02 + x07) | 0; x13 = rotl(x13 ^ x02, 16);\n    x08 = (x08 + x13) | 0; x07 = rotl(x07 ^ x08, 12);\n    x02 = (x02 + x07) | 0; x13 = rotl(x13 ^ x02, 8);\n    x08 = (x08 + x13) | 0; x07 = rotl(x07 ^ x08, 7);\n\n    x03 = (x03 + x04) | 0; x14 = rotl(x14 ^ x03, 16)\n    x09 = (x09 + x14) | 0; x04 = rotl(x04 ^ x09, 12);\n    x03 = (x03 + x04) | 0; x14 = rotl(x14 ^ x03, 8);\n    x09 = (x09 + x14) | 0; x04 = rotl(x04 ^ x09, 7);\n  }\n  // Write output\n  let oi = 0;\n  out[oi++] = (y00 + x00) | 0; out[oi++] = (y01 + x01) | 0;\n  out[oi++] = (y02 + x02) | 0; out[oi++] = (y03 + x03) | 0;\n  out[oi++] = (y04 + x04) | 0; out[oi++] = (y05 + x05) | 0;\n  out[oi++] = (y06 + x06) | 0; out[oi++] = (y07 + x07) | 0;\n  out[oi++] = (y08 + x08) | 0; out[oi++] = (y09 + x09) | 0;\n  out[oi++] = (y10 + x10) | 0; out[oi++] = (y11 + x11) | 0;\n  out[oi++] = (y12 + x12) | 0; out[oi++] = (y13 + x13) | 0;\n  out[oi++] = (y14 + x14) | 0; out[oi++] = (y15 + x15) | 0;\n}\n/**\n * hchacha helper method, used primarily in xchacha, to hash\n * key and nonce into key' and nonce'.\n * Same as chachaCore, but there doesn't seem to be a way to move the block\n * out without 25% performance hit.\n */\n// prettier-ignore\nexport function hchacha(\n  s: Uint32Array, k: Uint32Array, i: Uint32Array, o32: Uint32Array\n): void {\n  let x00 = s[0], x01 = s[1], x02 = s[2], x03 = s[3],\n      x04 = k[0], x05 = k[1], x06 = k[2], x07 = k[3],\n      x08 = k[4], x09 = k[5], x10 = k[6], x11 = k[7],\n      x12 = i[0], x13 = i[1], x14 = i[2], x15 = i[3];\n  for (let r = 0; r < 20; r += 2) {\n    x00 = (x00 + x04) | 0; x12 = rotl(x12 ^ x00, 16);\n    x08 = (x08 + x12) | 0; x04 = rotl(x04 ^ x08, 12);\n    x00 = (x00 + x04) | 0; x12 = rotl(x12 ^ x00, 8);\n    x08 = (x08 + x12) | 0; x04 = rotl(x04 ^ x08, 7);\n\n    x01 = (x01 + x05) | 0; x13 = rotl(x13 ^ x01, 16);\n    x09 = (x09 + x13) | 0; x05 = rotl(x05 ^ x09, 12);\n    x01 = (x01 + x05) | 0; x13 = rotl(x13 ^ x01, 8);\n    x09 = (x09 + x13) | 0; x05 = rotl(x05 ^ x09, 7);\n\n    x02 = (x02 + x06) | 0; x14 = rotl(x14 ^ x02, 16);\n    x10 = (x10 + x14) | 0; x06 = rotl(x06 ^ x10, 12);\n    x02 = (x02 + x06) | 0; x14 = rotl(x14 ^ x02, 8);\n    x10 = (x10 + x14) | 0; x06 = rotl(x06 ^ x10, 7);\n\n    x03 = (x03 + x07) | 0; x15 = rotl(x15 ^ x03, 16);\n    x11 = (x11 + x15) | 0; x07 = rotl(x07 ^ x11, 12);\n    x03 = (x03 + x07) | 0; x15 = rotl(x15 ^ x03, 8)\n    x11 = (x11 + x15) | 0; x07 = rotl(x07 ^ x11, 7);\n\n    x00 = (x00 + x05) | 0; x15 = rotl(x15 ^ x00, 16);\n    x10 = (x10 + x15) | 0; x05 = rotl(x05 ^ x10, 12);\n    x00 = (x00 + x05) | 0; x15 = rotl(x15 ^ x00, 8);\n    x10 = (x10 + x15) | 0; x05 = rotl(x05 ^ x10, 7);\n\n    x01 = (x01 + x06) | 0; x12 = rotl(x12 ^ x01, 16);\n    x11 = (x11 + x12) | 0; x06 = rotl(x06 ^ x11, 12);\n    x01 = (x01 + x06) | 0; x12 = rotl(x12 ^ x01, 8);\n    x11 = (x11 + x12) | 0; x06 = rotl(x06 ^ x11, 7);\n\n    x02 = (x02 + x07) | 0; x13 = rotl(x13 ^ x02, 16);\n    x08 = (x08 + x13) | 0; x07 = rotl(x07 ^ x08, 12);\n    x02 = (x02 + x07) | 0; x13 = rotl(x13 ^ x02, 8);\n    x08 = (x08 + x13) | 0; x07 = rotl(x07 ^ x08, 7);\n\n    x03 = (x03 + x04) | 0; x14 = rotl(x14 ^ x03, 16)\n    x09 = (x09 + x14) | 0; x04 = rotl(x04 ^ x09, 12);\n    x03 = (x03 + x04) | 0; x14 = rotl(x14 ^ x03, 8);\n    x09 = (x09 + x14) | 0; x04 = rotl(x04 ^ x09, 7);\n  }\n  let oi = 0;\n  o32[oi++] = x00; o32[oi++] = x01;\n  o32[oi++] = x02; o32[oi++] = x03;\n  o32[oi++] = x12; o32[oi++] = x13;\n  o32[oi++] = x14; o32[oi++] = x15;\n}\n/**\n * Original, non-RFC chacha20 from DJB. 8-byte nonce, 8-byte counter.\n */\nexport const chacha20orig: XorStream = /* @__PURE__ */ createCipher(chachaCore, {\n  counterRight: false,\n  counterLength: 8,\n  allowShortKeys: true,\n});\n/**\n * ChaCha stream cipher. Conforms to RFC 8439 (IETF, TLS). 12-byte nonce, 4-byte counter.\n * With 12-byte nonce, it's not safe to use fill it with random (CSPRNG), due to collision chance.\n */\nexport const chacha20: XorStream = /* @__PURE__ */ createCipher(chachaCore, {\n  counterRight: false,\n  counterLength: 4,\n  allowShortKeys: false,\n});\n\n/**\n * XChaCha eXtended-nonce ChaCha. 24-byte nonce.\n * With 24-byte nonce, it's safe to use fill it with random (CSPRNG).\n * https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-xchacha\n */\nexport const xchacha20: XorStream = /* @__PURE__ */ createCipher(chachaCore, {\n  counterRight: false,\n  counterLength: 8,\n  extendNonceFn: hchacha,\n  allowShortKeys: false,\n});\n\n/**\n * Reduced 8-round chacha, described in original paper.\n */\nexport const chacha8: XorStream = /* @__PURE__ */ createCipher(chachaCore, {\n  counterRight: false,\n  counterLength: 4,\n  rounds: 8,\n});\n\n/**\n * Reduced 12-round chacha, described in original paper.\n */\nexport const chacha12: XorStream = /* @__PURE__ */ createCipher(chachaCore, {\n  counterRight: false,\n  counterLength: 4,\n  rounds: 12,\n});\n\nconst ZEROS16 = /* @__PURE__ */ new Uint8Array(16);\n// Pad to digest size with zeros\nconst updatePadded = (h: ReturnType<typeof poly1305.create>, msg: Uint8Array) => {\n  h.update(msg);\n  const left = msg.length % 16;\n  if (left) h.update(ZEROS16.subarray(left));\n};\n\nconst ZEROS32 = /* @__PURE__ */ new Uint8Array(32);\nfunction computeTag(\n  fn: XorStream,\n  key: Uint8Array,\n  nonce: Uint8Array,\n  data: Uint8Array,\n  AAD?: Uint8Array\n): Uint8Array {\n  const authKey = fn(key, nonce, ZEROS32);\n  const h = poly1305.create(authKey);\n  if (AAD) updatePadded(h, AAD);\n  updatePadded(h, data);\n  const num = u64Lengths(data.length, AAD ? AAD.length : 0, true);\n  h.update(num);\n  const res = h.digest();\n  clean(authKey, num);\n  return res;\n}\n\n/**\n * AEAD algorithm from RFC 8439.\n * Salsa20 and chacha (RFC 8439) use poly1305 differently.\n * We could have composed them similar to:\n * https://github.com/paulmillr/scure-base/blob/b266c73dde977b1dd7ef40ef7a23cc15aab526b3/index.ts#L250\n * But it's hard because of authKey:\n * In salsa20, authKey changes position in salsa stream.\n * In chacha, authKey can't be computed inside computeTag, it modifies the counter.\n */\nexport const _poly1305_aead =\n  (xorStream: XorStream) =>\n  (key: Uint8Array, nonce: Uint8Array, AAD?: Uint8Array): CipherWithOutput => {\n    const tagLength = 16;\n    return {\n      encrypt(plaintext: Uint8Array, output?: Uint8Array) {\n        const plength = plaintext.length;\n        output = getOutput(plength + tagLength, output, false);\n        output.set(plaintext);\n        const oPlain = output.subarray(0, -tagLength);\n        xorStream(key, nonce, oPlain, oPlain, 1);\n        const tag = computeTag(xorStream, key, nonce, oPlain, AAD);\n        output.set(tag, plength); // append tag\n        clean(tag);\n        return output;\n      },\n      decrypt(ciphertext: Uint8Array, output?: Uint8Array) {\n        output = getOutput(ciphertext.length - tagLength, output, false);\n        const data = ciphertext.subarray(0, -tagLength);\n        const passedTag = ciphertext.subarray(-tagLength);\n        const tag = computeTag(xorStream, key, nonce, data, AAD);\n        if (!equalBytes(passedTag, tag)) throw new Error('invalid tag');\n        output.set(ciphertext.subarray(0, -tagLength));\n        xorStream(key, nonce, output, output, 1); // start stream with i=1\n        clean(tag);\n        return output;\n      },\n    };\n  };\n\n/**\n * ChaCha20-Poly1305 from RFC 8439.\n *\n * Unsafe to use random nonces under the same key, due to collision chance.\n * Prefer XChaCha instead.\n */\nexport const chacha20poly1305: ARXCipher = /* @__PURE__ */ wrapCipher(\n  { blockSize: 64, nonceLength: 12, tagLength: 16 },\n  _poly1305_aead(chacha20)\n);\n/**\n * XChaCha20-Poly1305 extended-nonce chacha.\n *\n * Can be safely used with random nonces (CSPRNG).\n * See [IRTF draft](https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-xchacha).\n */\nexport const xchacha20poly1305: ARXCipher = /* @__PURE__ */ wrapCipher(\n  { blockSize: 64, nonceLength: 24, tagLength: 16 },\n  _poly1305_aead(xchacha20)\n);\n", "/**\n * Utilities for hex, bytes, CSPRNG.\n * @module\n */\n/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n\n// We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.\n// node.js versions earlier than v19 don't declare it in global scope.\n// For node.js, package.json#exports field mapping rewrites import\n// from `crypto` to `cryptoNode`, which imports native module.\n// Makes the utils un-importable in browsers without a bundler.\n// Once node.js 18 is deprecated (2025-04-30), we can just drop the import.\nimport { crypto } from '@noble/hashes/crypto';\n\n/** Checks if something is Uint8Array. Be careful: nodejs Buffer will return true. */\nexport function isBytes(a: unknown): a is Uint8Array {\n  return a instanceof Uint8Array || (ArrayBuffer.isView(a) && a.constructor.name === 'Uint8Array');\n}\n\n/** Asserts something is positive integer. */\nexport function anumber(n: number): void {\n  if (!Number.isSafeInteger(n) || n < 0) throw new Error('positive integer expected, got ' + n);\n}\n\n/** Asserts something is Uint8Array. */\nexport function abytes(b: Uint8Array | undefined, ...lengths: number[]): void {\n  if (!isBytes(b)) throw new Error('Uint8Array expected');\n  if (lengths.length > 0 && !lengths.includes(b.length))\n    throw new Error('Uint8Array expected of length ' + lengths + ', got length=' + b.length);\n}\n\n/** Asserts something is hash */\nexport function ahash(h: IHash): void {\n  if (typeof h !== 'function' || typeof h.create !== 'function')\n    throw new Error('Hash should be wrapped by utils.createHasher');\n  anumber(h.outputLen);\n  anumber(h.blockLen);\n}\n\n/** Asserts a hash instance has not been destroyed / finished */\nexport function aexists(instance: any, checkFinished = true): void {\n  if (instance.destroyed) throw new Error('Hash instance has been destroyed');\n  if (checkFinished && instance.finished) throw new Error('Hash#digest() has already been called');\n}\n\n/** Asserts output is properly-sized byte array */\nexport function aoutput(out: any, instance: any): void {\n  abytes(out);\n  const min = instance.outputLen;\n  if (out.length < min) {\n    throw new Error('digestInto() expects output buffer of length at least ' + min);\n  }\n}\n\n/** Generic type encompassing 8/16/32-byte arrays - but not 64-byte. */\n// prettier-ignore\nexport type TypedArray = Int8Array | Uint8ClampedArray | Uint8Array |\n  Uint16Array | Int16Array | Uint32Array | Int32Array;\n\n/** Cast u8 / u16 / u32 to u8. */\nexport function u8(arr: TypedArray): Uint8Array {\n  return new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\n}\n\n/** Cast u8 / u16 / u32 to u32. */\nexport function u32(arr: TypedArray): Uint32Array {\n  return new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));\n}\n\n/** Zeroize a byte array. Warning: JS provides no guarantees. */\nexport function clean(...arrays: TypedArray[]): void {\n  for (let i = 0; i < arrays.length; i++) {\n    arrays[i].fill(0);\n  }\n}\n\n/** Create DataView of an array for easy byte-level manipulation. */\nexport function createView(arr: TypedArray): DataView {\n  return new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\n}\n\n/** The rotate right (circular right shift) operation for uint32 */\nexport function rotr(word: number, shift: number): number {\n  return (word << (32 - shift)) | (word >>> shift);\n}\n\n/** The rotate left (circular left shift) operation for uint32 */\nexport function rotl(word: number, shift: number): number {\n  return (word << shift) | ((word >>> (32 - shift)) >>> 0);\n}\n\n/** Is current platform little-endian? Most are. Big-Endian platform: IBM */\nexport const isLE: boolean = /* @__PURE__ */ (() =>\n  new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44)();\n\n/** The byte swap operation for uint32 */\nexport function byteSwap(word: number): number {\n  return (\n    ((word << 24) & 0xff000000) |\n    ((word << 8) & 0xff0000) |\n    ((word >>> 8) & 0xff00) |\n    ((word >>> 24) & 0xff)\n  );\n}\n/** Conditionally byte swap if on a big-endian platform */\nexport const swap8IfBE: (n: number) => number = isLE\n  ? (n: number) => n\n  : (n: number) => byteSwap(n);\n\n/** @deprecated */\nexport const byteSwapIfBE: typeof swap8IfBE = swap8IfBE;\n/** In place byte swap for Uint32Array */\nexport function byteSwap32(arr: Uint32Array): Uint32Array {\n  for (let i = 0; i < arr.length; i++) {\n    arr[i] = byteSwap(arr[i]);\n  }\n  return arr;\n}\n\nexport const swap32IfBE: (u: Uint32Array) => Uint32Array = isLE\n  ? (u: Uint32Array) => u\n  : byteSwap32;\n\n// Built-in hex conversion https://caniuse.com/mdn-javascript_builtins_uint8array_fromhex\nconst hasHexBuiltin: boolean = /* @__PURE__ */ (() =>\n  // @ts-ignore\n  typeof Uint8Array.from([]).toHex === 'function' && typeof Uint8Array.fromHex === 'function')();\n\n// Array where index 0xf0 (240) is mapped to string 'f0'\nconst hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) =>\n  i.toString(16).padStart(2, '0')\n);\n\n/**\n * Convert byte array to hex string. Uses built-in function, when available.\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */\nexport function bytesToHex(bytes: Uint8Array): string {\n  abytes(bytes);\n  // @ts-ignore\n  if (hasHexBuiltin) return bytes.toHex();\n  // pre-caching improves the speed 6x\n  let hex = '';\n  for (let i = 0; i < bytes.length; i++) {\n    hex += hexes[bytes[i]];\n  }\n  return hex;\n}\n\n// We use optimized technique to convert hex string to byte array\nconst asciis = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 } as const;\nfunction asciiToBase16(ch: number): number | undefined {\n  if (ch >= asciis._0 && ch <= asciis._9) return ch - asciis._0; // '2' => 50-48\n  if (ch >= asciis.A && ch <= asciis.F) return ch - (asciis.A - 10); // 'B' => 66-(65-10)\n  if (ch >= asciis.a && ch <= asciis.f) return ch - (asciis.a - 10); // 'b' => 98-(97-10)\n  return;\n}\n\n/**\n * Convert hex string to byte array. Uses built-in function, when available.\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */\nexport function hexToBytes(hex: string): Uint8Array {\n  if (typeof hex !== 'string') throw new Error('hex string expected, got ' + typeof hex);\n  // @ts-ignore\n  if (hasHexBuiltin) return Uint8Array.fromHex(hex);\n  const hl = hex.length;\n  const al = hl / 2;\n  if (hl % 2) throw new Error('hex string expected, got unpadded hex of length ' + hl);\n  const array = new Uint8Array(al);\n  for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {\n    const n1 = asciiToBase16(hex.charCodeAt(hi));\n    const n2 = asciiToBase16(hex.charCodeAt(hi + 1));\n    if (n1 === undefined || n2 === undefined) {\n      const char = hex[hi] + hex[hi + 1];\n      throw new Error('hex string expected, got non-hex character \"' + char + '\" at index ' + hi);\n    }\n    array[ai] = n1 * 16 + n2; // multiply first octet, e.g. 'a3' => 10*16+3 => 160 + 3 => 163\n  }\n  return array;\n}\n\n/**\n * There is no setImmediate in browser and setTimeout is slow.\n * Call of async fn will return Promise, which will be fullfiled only on\n * next scheduler queue processing step and this is exactly what we need.\n */\nexport const nextTick = async (): Promise<void> => {};\n\n/** Returns control to thread each 'tick' ms to avoid blocking. */\nexport async function asyncLoop(\n  iters: number,\n  tick: number,\n  cb: (i: number) => void\n): Promise<void> {\n  let ts = Date.now();\n  for (let i = 0; i < iters; i++) {\n    cb(i);\n    // Date.now() is not monotonic, so in case if clock goes backwards we return return control too\n    const diff = Date.now() - ts;\n    if (diff >= 0 && diff < tick) continue;\n    await nextTick();\n    ts += diff;\n  }\n}\n\n// Global symbols, but ts doesn't see them: https://github.com/microsoft/TypeScript/issues/31535\ndeclare const TextEncoder: any;\ndeclare const TextDecoder: any;\n\n/**\n * Converts string to bytes using UTF8 encoding.\n * @example utf8ToBytes('abc') // Uint8Array.from([97, 98, 99])\n */\nexport function utf8ToBytes(str: string): Uint8Array {\n  if (typeof str !== 'string') throw new Error('string expected');\n  return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n\n/**\n * Converts bytes to string using UTF8 encoding.\n * @example bytesToUtf8(Uint8Array.from([97, 98, 99])) // 'abc'\n */\nexport function bytesToUtf8(bytes: Uint8Array): string {\n  return new TextDecoder().decode(bytes);\n}\n\n/** Accepted input of hash functions. Strings are converted to byte arrays. */\nexport type Input = string | Uint8Array;\n/**\n * Normalizes (non-hex) string or Uint8Array to Uint8Array.\n * Warning: when Uint8Array is passed, it would NOT get copied.\n * Keep in mind for future mutable operations.\n */\nexport function toBytes(data: Input): Uint8Array {\n  if (typeof data === 'string') data = utf8ToBytes(data);\n  abytes(data);\n  return data;\n}\n\n/** KDFs can accept string or Uint8Array for user convenience. */\nexport type KDFInput = string | Uint8Array;\n/**\n * Helper for KDFs: consumes uint8array or string.\n * When string is passed, does utf8 decoding, using TextDecoder.\n */\nexport function kdfInputToBytes(data: KDFInput): Uint8Array {\n  if (typeof data === 'string') data = utf8ToBytes(data);\n  abytes(data);\n  return data;\n}\n\n/** Copies several Uint8Arrays into one. */\nexport function concatBytes(...arrays: Uint8Array[]): Uint8Array {\n  let sum = 0;\n  for (let i = 0; i < arrays.length; i++) {\n    const a = arrays[i];\n    abytes(a);\n    sum += a.length;\n  }\n  const res = new Uint8Array(sum);\n  for (let i = 0, pad = 0; i < arrays.length; i++) {\n    const a = arrays[i];\n    res.set(a, pad);\n    pad += a.length;\n  }\n  return res;\n}\n\ntype EmptyObj = {};\nexport function checkOpts<T1 extends EmptyObj, T2 extends EmptyObj>(\n  defaults: T1,\n  opts?: T2\n): T1 & T2 {\n  if (opts !== undefined && {}.toString.call(opts) !== '[object Object]')\n    throw new Error('options should be object or undefined');\n  const merged = Object.assign(defaults, opts);\n  return merged as T1 & T2;\n}\n\n/** Hash interface. */\nexport type IHash = {\n  (data: Uint8Array): Uint8Array;\n  blockLen: number;\n  outputLen: number;\n  create: any;\n};\n\n/** For runtime check if class implements interface */\nexport abstract class Hash<T extends Hash<T>> {\n  abstract blockLen: number; // Bytes per block\n  abstract outputLen: number; // Bytes in output\n  abstract update(buf: Input): this;\n  // Writes digest into buf\n  abstract digestInto(buf: Uint8Array): void;\n  abstract digest(): Uint8Array;\n  /**\n   * Resets internal state. Makes Hash instance unusable.\n   * Reset is impossible for keyed hashes if key is consumed into state. If digest is not consumed\n   * by user, they will need to manually call `destroy()` when zeroing is necessary.\n   */\n  abstract destroy(): void;\n  /**\n   * Clones hash instance. Unsafe: doesn't check whether `to` is valid. Can be used as `clone()`\n   * when no options are passed.\n   * Reasons to use `_cloneInto` instead of clone: 1) performance 2) reuse instance => all internal\n   * buffers are overwritten => causes buffer overwrite which is used for digest in some cases.\n   * There are no guarantees for clean-up because it's impossible in JS.\n   */\n  abstract _cloneInto(to?: T): T;\n  // Safe version that clones internal state\n  abstract clone(): T;\n}\n\n/**\n * XOF: streaming API to read digest in chunks.\n * Same as 'squeeze' in keccak/k12 and 'seek' in blake3, but more generic name.\n * When hash used in XOF mode it is up to user to call '.destroy' afterwards, since we cannot\n * destroy state, next call can require more bytes.\n */\nexport type HashXOF<T extends Hash<T>> = Hash<T> & {\n  xof(bytes: number): Uint8Array; // Read 'bytes' bytes from digest stream\n  xofInto(buf: Uint8Array): Uint8Array; // read buf.length bytes from digest stream into buf\n};\n\n/** Hash function */\nexport type CHash = ReturnType<typeof createHasher>;\n/** Hash function with output */\nexport type CHashO = ReturnType<typeof createOptHasher>;\n/** XOF with output */\nexport type CHashXO = ReturnType<typeof createXOFer>;\n\n/** Wraps hash function, creating an interface on top of it */\nexport function createHasher<T extends Hash<T>>(\n  hashCons: () => Hash<T>\n): {\n  (msg: Input): Uint8Array;\n  outputLen: number;\n  blockLen: number;\n  create(): Hash<T>;\n} {\n  const hashC = (msg: Input): Uint8Array => hashCons().update(toBytes(msg)).digest();\n  const tmp = hashCons();\n  hashC.outputLen = tmp.outputLen;\n  hashC.blockLen = tmp.blockLen;\n  hashC.create = () => hashCons();\n  return hashC;\n}\n\nexport function createOptHasher<H extends Hash<H>, T extends Object>(\n  hashCons: (opts?: T) => Hash<H>\n): {\n  (msg: Input, opts?: T): Uint8Array;\n  outputLen: number;\n  blockLen: number;\n  create(opts?: T): Hash<H>;\n} {\n  const hashC = (msg: Input, opts?: T): Uint8Array => hashCons(opts).update(toBytes(msg)).digest();\n  const tmp = hashCons({} as T);\n  hashC.outputLen = tmp.outputLen;\n  hashC.blockLen = tmp.blockLen;\n  hashC.create = (opts?: T) => hashCons(opts);\n  return hashC;\n}\n\nexport function createXOFer<H extends HashXOF<H>, T extends Object>(\n  hashCons: (opts?: T) => HashXOF<H>\n): {\n  (msg: Input, opts?: T): Uint8Array;\n  outputLen: number;\n  blockLen: number;\n  create(opts?: T): HashXOF<H>;\n} {\n  const hashC = (msg: Input, opts?: T): Uint8Array => hashCons(opts).update(toBytes(msg)).digest();\n  const tmp = hashCons({} as T);\n  hashC.outputLen = tmp.outputLen;\n  hashC.blockLen = tmp.blockLen;\n  hashC.create = (opts?: T) => hashCons(opts);\n  return hashC;\n}\nexport const wrapConstructor: typeof createHasher = createHasher;\nexport const wrapConstructorWithOpts: typeof createOptHasher = createOptHasher;\nexport const wrapXOFConstructorWithOpts: typeof createXOFer = createXOFer;\n\n/** Cryptographically secure PRNG. Uses internal OS-level `crypto.getRandomValues`. */\nexport function randomBytes(bytesLength = 32): Uint8Array {\n  if (crypto && typeof crypto.getRandomValues === 'function') {\n    return crypto.getRandomValues(new Uint8Array(bytesLength));\n  }\n  // Legacy Node.js compatibility\n  if (crypto && typeof crypto.randomBytes === 'function') {\n    return Uint8Array.from(crypto.randomBytes(bytesLength));\n  }\n  throw new Error('crypto.getRandomValues must be defined');\n}\n", "/**\n * HMAC: RFC2104 message authentication code.\n * @module\n */\nimport { abytes, aexists, ahash, clean, Hash, toBytes, type CHash, type Input } from './utils.ts';\n\nexport class HMAC<T extends Hash<T>> extends Hash<HMAC<T>> {\n  oHash: T;\n  iHash: T;\n  blockLen: number;\n  outputLen: number;\n  private finished = false;\n  private destroyed = false;\n\n  constructor(hash: CHash, _key: Input) {\n    super();\n    ahash(hash);\n    const key = toBytes(_key);\n    this.iHash = hash.create() as T;\n    if (typeof this.iHash.update !== 'function')\n      throw new Error('Expected instance of class which extends utils.Hash');\n    this.blockLen = this.iHash.blockLen;\n    this.outputLen = this.iHash.outputLen;\n    const blockLen = this.blockLen;\n    const pad = new Uint8Array(blockLen);\n    // blockLen can be bigger than outputLen\n    pad.set(key.length > blockLen ? hash.create().update(key).digest() : key);\n    for (let i = 0; i < pad.length; i++) pad[i] ^= 0x36;\n    this.iHash.update(pad);\n    // By doing update (processing of first block) of outer hash here we can re-use it between multiple calls via clone\n    this.oHash = hash.create() as T;\n    // Undo internal XOR && apply outer XOR\n    for (let i = 0; i < pad.length; i++) pad[i] ^= 0x36 ^ 0x5c;\n    this.oHash.update(pad);\n    clean(pad);\n  }\n  update(buf: Input): this {\n    aexists(this);\n    this.iHash.update(buf);\n    return this;\n  }\n  digestInto(out: Uint8Array): void {\n    aexists(this);\n    abytes(out, this.outputLen);\n    this.finished = true;\n    this.iHash.digestInto(out);\n    this.oHash.update(out);\n    this.oHash.digestInto(out);\n    this.destroy();\n  }\n  digest(): Uint8Array {\n    const out = new Uint8Array(this.oHash.outputLen);\n    this.digestInto(out);\n    return out;\n  }\n  _cloneInto(to?: HMAC<T>): HMAC<T> {\n    // Create new instance without calling constructor since key already in state and we don't know it.\n    to ||= Object.create(Object.getPrototypeOf(this), {});\n    const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;\n    to = to as this;\n    to.finished = finished;\n    to.destroyed = destroyed;\n    to.blockLen = blockLen;\n    to.outputLen = outputLen;\n    to.oHash = oHash._cloneInto(to.oHash);\n    to.iHash = iHash._cloneInto(to.iHash);\n    return to;\n  }\n  clone(): HMAC<T> {\n    return this._cloneInto();\n  }\n  destroy(): void {\n    this.destroyed = true;\n    this.oHash.destroy();\n    this.iHash.destroy();\n  }\n}\n\n/**\n * HMAC: RFC2104 message authentication code.\n * @param hash - function that would be used e.g. sha256\n * @param key - message key\n * @param message - message data\n * @example\n * import { hmac } from '@noble/hashes/hmac';\n * import { sha256 } from '@noble/hashes/sha2';\n * const mac1 = hmac(sha256, 'key', 'message');\n */\nexport const hmac: {\n  (hash: CHash, key: Input, message: Input): Uint8Array;\n  create(hash: CHash, key: Input): HMAC<any>;\n} = (hash: CHash, key: Input, message: Input): Uint8Array =>\n  new HMAC<any>(hash, key).update(message).digest();\nhmac.create = (hash: CHash, key: Input) => new HMAC<any>(hash, key);\n", "/**\n * PBKDF (RFC 2898). Can be used to create a key from password and salt.\n * @module\n */\nimport { hmac } from './hmac.ts';\n// prettier-ignore\nimport {\n  ahash, anumber,\n  asyncLoop, checkOpts, clean, createView, Hash, kdfInputToBytes,\n  type CHash,\n  type KDFInput\n} from './utils.ts';\n\nexport type Pbkdf2Opt = {\n  c: number; // Iterations\n  dkLen?: number; // Desired key length in bytes (Intended output length in octets of the derived key\n  asyncTick?: number; // Maximum time in ms for which async function can block execution\n};\n// Common prologue and epilogue for sync/async functions\nfunction pbkdf2Init(hash: CHash, _password: KDFInput, _salt: KDFInput, _opts: Pbkdf2Opt) {\n  ahash(hash);\n  const opts = checkOpts({ dkLen: 32, asyncTick: 10 }, _opts);\n  const { c, dkLen, asyncTick } = opts;\n  anumber(c);\n  anumber(dkLen);\n  anumber(asyncTick);\n  if (c < 1) throw new Error('iterations (c) should be >= 1');\n  const password = kdfInputToBytes(_password);\n  const salt = kdfInputToBytes(_salt);\n  // DK = PBKDF2(PRF, Password, Salt, c, dkLen);\n  const DK = new Uint8Array(dkLen);\n  // U1 = PRF(Password, Salt + INT_32_BE(i))\n  const PRF = hmac.create(hash, password);\n  const PRFSalt = PRF._cloneInto().update(salt);\n  return { c, dkLen, asyncTick, DK, PRF, PRFSalt };\n}\n\nfunction pbkdf2Output<T extends Hash<T>>(\n  PRF: Hash<T>,\n  PRFSalt: Hash<T>,\n  DK: Uint8Array,\n  prfW: Hash<T>,\n  u: Uint8Array\n) {\n  PRF.destroy();\n  PRFSalt.destroy();\n  if (prfW) prfW.destroy();\n  clean(u);\n  return DK;\n}\n\n/**\n * PBKDF2-HMAC: RFC 2898 key derivation function\n * @param hash - hash function that would be used e.g. sha256\n * @param password - password from which a derived key is generated\n * @param salt - cryptographic salt\n * @param opts - {c, dkLen} where c is work factor and dkLen is output message size\n * @example\n * const key = pbkdf2(sha256, 'password', 'salt', { dkLen: 32, c: Math.pow(2, 18) });\n */\nexport function pbkdf2(\n  hash: CHash,\n  password: KDFInput,\n  salt: KDFInput,\n  opts: Pbkdf2Opt\n): Uint8Array {\n  const { c, dkLen, DK, PRF, PRFSalt } = pbkdf2Init(hash, password, salt, opts);\n  let prfW: any; // Working copy\n  const arr = new Uint8Array(4);\n  const view = createView(arr);\n  const u = new Uint8Array(PRF.outputLen);\n  // DK = T1 + T2 + \u22EF + Tdklen/hlen\n  for (let ti = 1, pos = 0; pos < dkLen; ti++, pos += PRF.outputLen) {\n    // Ti = F(Password, Salt, c, i)\n    const Ti = DK.subarray(pos, pos + PRF.outputLen);\n    view.setInt32(0, ti, false);\n    // F(Password, Salt, c, i) = U1 ^ U2 ^ \u22EF ^ Uc\n    // U1 = PRF(Password, Salt + INT_32_BE(i))\n    (prfW = PRFSalt._cloneInto(prfW)).update(arr).digestInto(u);\n    Ti.set(u.subarray(0, Ti.length));\n    for (let ui = 1; ui < c; ui++) {\n      // Uc = PRF(Password, Uc\u22121)\n      PRF._cloneInto(prfW).update(u).digestInto(u);\n      for (let i = 0; i < Ti.length; i++) Ti[i] ^= u[i];\n    }\n  }\n  return pbkdf2Output(PRF, PRFSalt, DK, prfW, u);\n}\n\n/**\n * PBKDF2-HMAC: RFC 2898 key derivation function. Async version.\n * @example\n * await pbkdf2Async(sha256, 'password', 'salt', { dkLen: 32, c: 500_000 });\n */\nexport async function pbkdf2Async(\n  hash: CHash,\n  password: KDFInput,\n  salt: KDFInput,\n  opts: Pbkdf2Opt\n): Promise<Uint8Array> {\n  const { c, dkLen, asyncTick, DK, PRF, PRFSalt } = pbkdf2Init(hash, password, salt, opts);\n  let prfW: any; // Working copy\n  const arr = new Uint8Array(4);\n  const view = createView(arr);\n  const u = new Uint8Array(PRF.outputLen);\n  // DK = T1 + T2 + \u22EF + Tdklen/hlen\n  for (let ti = 1, pos = 0; pos < dkLen; ti++, pos += PRF.outputLen) {\n    // Ti = F(Password, Salt, c, i)\n    const Ti = DK.subarray(pos, pos + PRF.outputLen);\n    view.setInt32(0, ti, false);\n    // F(Password, Salt, c, i) = U1 ^ U2 ^ \u22EF ^ Uc\n    // U1 = PRF(Password, Salt + INT_32_BE(i))\n    (prfW = PRFSalt._cloneInto(prfW)).update(arr).digestInto(u);\n    Ti.set(u.subarray(0, Ti.length));\n    await asyncLoop(c - 1, asyncTick, () => {\n      // Uc = PRF(Password, Uc\u22121)\n      PRF._cloneInto(prfW).update(u).digestInto(u);\n      for (let i = 0; i < Ti.length; i++) Ti[i] ^= u[i];\n    });\n  }\n  return pbkdf2Output(PRF, PRFSalt, DK, prfW, u);\n}\n", "/**\n * Internal Merkle-Damgard hash utils.\n * @module\n */\nimport { type Input, Hash, abytes, aexists, aoutput, clean, createView, toBytes } from './utils.ts';\n\n/** Polyfill for Safari 14. https://caniuse.com/mdn-javascript_builtins_dataview_setbiguint64 */\nexport function setBigUint64(\n  view: DataView,\n  byteOffset: number,\n  value: bigint,\n  isLE: boolean\n): void {\n  if (typeof view.setBigUint64 === 'function') return view.setBigUint64(byteOffset, value, isLE);\n  const _32n = BigInt(32);\n  const _u32_max = BigInt(0xffffffff);\n  const wh = Number((value >> _32n) & _u32_max);\n  const wl = Number(value & _u32_max);\n  const h = isLE ? 4 : 0;\n  const l = isLE ? 0 : 4;\n  view.setUint32(byteOffset + h, wh, isLE);\n  view.setUint32(byteOffset + l, wl, isLE);\n}\n\n/** Choice: a ? b : c */\nexport function Chi(a: number, b: number, c: number): number {\n  return (a & b) ^ (~a & c);\n}\n\n/** Majority function, true if any two inputs is true. */\nexport function Maj(a: number, b: number, c: number): number {\n  return (a & b) ^ (a & c) ^ (b & c);\n}\n\n/**\n * Merkle-Damgard hash construction base class.\n * Could be used to create MD5, RIPEMD, SHA1, SHA2.\n */\nexport abstract class HashMD<T extends HashMD<T>> extends Hash<T> {\n  protected abstract process(buf: DataView, offset: number): void;\n  protected abstract get(): number[];\n  protected abstract set(...args: number[]): void;\n  abstract destroy(): void;\n  protected abstract roundClean(): void;\n\n  readonly blockLen: number;\n  readonly outputLen: number;\n  readonly padOffset: number;\n  readonly isLE: boolean;\n\n  // For partial updates less than block size\n  protected buffer: Uint8Array;\n  protected view: DataView;\n  protected finished = false;\n  protected length = 0;\n  protected pos = 0;\n  protected destroyed = false;\n\n  constructor(blockLen: number, outputLen: number, padOffset: number, isLE: boolean) {\n    super();\n    this.blockLen = blockLen;\n    this.outputLen = outputLen;\n    this.padOffset = padOffset;\n    this.isLE = isLE;\n    this.buffer = new Uint8Array(blockLen);\n    this.view = createView(this.buffer);\n  }\n  update(data: Input): this {\n    aexists(this);\n    data = toBytes(data);\n    abytes(data);\n    const { view, buffer, blockLen } = this;\n    const len = data.length;\n    for (let pos = 0; pos < len; ) {\n      const take = Math.min(blockLen - this.pos, len - pos);\n      // Fast path: we have at least one block in input, cast it to view and process\n      if (take === blockLen) {\n        const dataView = createView(data);\n        for (; blockLen <= len - pos; pos += blockLen) this.process(dataView, pos);\n        continue;\n      }\n      buffer.set(data.subarray(pos, pos + take), this.pos);\n      this.pos += take;\n      pos += take;\n      if (this.pos === blockLen) {\n        this.process(view, 0);\n        this.pos = 0;\n      }\n    }\n    this.length += data.length;\n    this.roundClean();\n    return this;\n  }\n  digestInto(out: Uint8Array): void {\n    aexists(this);\n    aoutput(out, this);\n    this.finished = true;\n    // Padding\n    // We can avoid allocation of buffer for padding completely if it\n    // was previously not allocated here. But it won't change performance.\n    const { buffer, view, blockLen, isLE } = this;\n    let { pos } = this;\n    // append the bit '1' to the message\n    buffer[pos++] = 0b10000000;\n    clean(this.buffer.subarray(pos));\n    // we have less than padOffset left in buffer, so we cannot put length in\n    // current block, need process it and pad again\n    if (this.padOffset > blockLen - pos) {\n      this.process(view, 0);\n      pos = 0;\n    }\n    // Pad until full block byte with zeros\n    for (let i = pos; i < blockLen; i++) buffer[i] = 0;\n    // Note: sha512 requires length to be 128bit integer, but length in JS will overflow before that\n    // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.\n    // So we just write lowest 64 bits of that value.\n    setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);\n    this.process(view, 0);\n    const oview = createView(out);\n    const len = this.outputLen;\n    // NOTE: we do division by 4 later, which should be fused in single op with modulo by JIT\n    if (len % 4) throw new Error('_sha2: outputLen should be aligned to 32bit');\n    const outLen = len / 4;\n    const state = this.get();\n    if (outLen > state.length) throw new Error('_sha2: outputLen bigger than state');\n    for (let i = 0; i < outLen; i++) oview.setUint32(4 * i, state[i], isLE);\n  }\n  digest(): Uint8Array {\n    const { buffer, outputLen } = this;\n    this.digestInto(buffer);\n    const res = buffer.slice(0, outputLen);\n    this.destroy();\n    return res;\n  }\n  _cloneInto(to?: T): T {\n    to ||= new (this.constructor as any)() as T;\n    to.set(...this.get());\n    const { blockLen, buffer, length, finished, destroyed, pos } = this;\n    to.destroyed = destroyed;\n    to.finished = finished;\n    to.length = length;\n    to.pos = pos;\n    if (length % blockLen) to.buffer.set(buffer);\n    return to;\n  }\n  clone(): T {\n    return this._cloneInto();\n  }\n}\n\n/**\n * Initial SHA-2 state: fractional parts of square roots of first 16 primes 2..53.\n * Check out `test/misc/sha2-gen-iv.js` for recomputation guide.\n */\n\n/** Initial SHA256 state. Bits 0..32 of frac part of sqrt of primes 2..19 */\nexport const SHA256_IV: Uint32Array = /* @__PURE__ */ Uint32Array.from([\n  0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19,\n]);\n\n/** Initial SHA224 state. Bits 32..64 of frac part of sqrt of primes 23..53 */\nexport const SHA224_IV: Uint32Array = /* @__PURE__ */ Uint32Array.from([\n  0xc1059ed8, 0x367cd507, 0x3070dd17, 0xf70e5939, 0xffc00b31, 0x68581511, 0x64f98fa7, 0xbefa4fa4,\n]);\n\n/** Initial SHA384 state. Bits 0..64 of frac part of sqrt of primes 23..53 */\nexport const SHA384_IV: Uint32Array = /* @__PURE__ */ Uint32Array.from([\n  0xcbbb9d5d, 0xc1059ed8, 0x629a292a, 0x367cd507, 0x9159015a, 0x3070dd17, 0x152fecd8, 0xf70e5939,\n  0x67332667, 0xffc00b31, 0x8eb44a87, 0x68581511, 0xdb0c2e0d, 0x64f98fa7, 0x47b5481d, 0xbefa4fa4,\n]);\n\n/** Initial SHA512 state. Bits 0..64 of frac part of sqrt of primes 2..19 */\nexport const SHA512_IV: Uint32Array = /* @__PURE__ */ Uint32Array.from([\n  0x6a09e667, 0xf3bcc908, 0xbb67ae85, 0x84caa73b, 0x3c6ef372, 0xfe94f82b, 0xa54ff53a, 0x5f1d36f1,\n  0x510e527f, 0xade682d1, 0x9b05688c, 0x2b3e6c1f, 0x1f83d9ab, 0xfb41bd6b, 0x5be0cd19, 0x137e2179,\n]);\n", "/**\n * SHA2 hash function. A.k.a. sha256, sha384, sha512, sha512_224, sha512_256.\n * SHA256 is the fastest hash implementable in JS, even faster than Blake3.\n * Check out [RFC 4634](https://datatracker.ietf.org/doc/html/rfc4634) and\n * [FIPS 180-4](https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf).\n * @module\n */\nimport { Chi, HashMD, Maj, SHA224_IV, SHA256_IV, SHA384_IV, SHA512_IV } from './_md.ts';\nimport * as u64 from './_u64.ts';\nimport { type CHash, clean, createHasher, rotr } from './utils.ts';\n\n/**\n * Round constants:\n * First 32 bits of fractional parts of the cube roots of the first 64 primes 2..311)\n */\n// prettier-ignore\nconst SHA256_K = /* @__PURE__ */ Uint32Array.from([\n  0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n  0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n  0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n  0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n  0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n  0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n  0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n  0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2\n]);\n\n/** Reusable temporary buffer. \"W\" comes straight from spec. */\nconst SHA256_W = /* @__PURE__ */ new Uint32Array(64);\nexport class SHA256 extends HashMD<SHA256> {\n  // We cannot use array here since array allows indexing by variable\n  // which means optimizer/compiler cannot use registers.\n  protected A: number = SHA256_IV[0] | 0;\n  protected B: number = SHA256_IV[1] | 0;\n  protected C: number = SHA256_IV[2] | 0;\n  protected D: number = SHA256_IV[3] | 0;\n  protected E: number = SHA256_IV[4] | 0;\n  protected F: number = SHA256_IV[5] | 0;\n  protected G: number = SHA256_IV[6] | 0;\n  protected H: number = SHA256_IV[7] | 0;\n\n  constructor(outputLen: number = 32) {\n    super(64, outputLen, 8, false);\n  }\n  protected get(): [number, number, number, number, number, number, number, number] {\n    const { A, B, C, D, E, F, G, H } = this;\n    return [A, B, C, D, E, F, G, H];\n  }\n  // prettier-ignore\n  protected set(\n    A: number, B: number, C: number, D: number, E: number, F: number, G: number, H: number\n  ): void {\n    this.A = A | 0;\n    this.B = B | 0;\n    this.C = C | 0;\n    this.D = D | 0;\n    this.E = E | 0;\n    this.F = F | 0;\n    this.G = G | 0;\n    this.H = H | 0;\n  }\n  protected process(view: DataView, offset: number): void {\n    // Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array\n    for (let i = 0; i < 16; i++, offset += 4) SHA256_W[i] = view.getUint32(offset, false);\n    for (let i = 16; i < 64; i++) {\n      const W15 = SHA256_W[i - 15];\n      const W2 = SHA256_W[i - 2];\n      const s0 = rotr(W15, 7) ^ rotr(W15, 18) ^ (W15 >>> 3);\n      const s1 = rotr(W2, 17) ^ rotr(W2, 19) ^ (W2 >>> 10);\n      SHA256_W[i] = (s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16]) | 0;\n    }\n    // Compression function main loop, 64 rounds\n    let { A, B, C, D, E, F, G, H } = this;\n    for (let i = 0; i < 64; i++) {\n      const sigma1 = rotr(E, 6) ^ rotr(E, 11) ^ rotr(E, 25);\n      const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;\n      const sigma0 = rotr(A, 2) ^ rotr(A, 13) ^ rotr(A, 22);\n      const T2 = (sigma0 + Maj(A, B, C)) | 0;\n      H = G;\n      G = F;\n      F = E;\n      E = (D + T1) | 0;\n      D = C;\n      C = B;\n      B = A;\n      A = (T1 + T2) | 0;\n    }\n    // Add the compressed chunk to the current hash value\n    A = (A + this.A) | 0;\n    B = (B + this.B) | 0;\n    C = (C + this.C) | 0;\n    D = (D + this.D) | 0;\n    E = (E + this.E) | 0;\n    F = (F + this.F) | 0;\n    G = (G + this.G) | 0;\n    H = (H + this.H) | 0;\n    this.set(A, B, C, D, E, F, G, H);\n  }\n  protected roundClean(): void {\n    clean(SHA256_W);\n  }\n  destroy(): void {\n    this.set(0, 0, 0, 0, 0, 0, 0, 0);\n    clean(this.buffer);\n  }\n}\n\nexport class SHA224 extends SHA256 {\n  protected A: number = SHA224_IV[0] | 0;\n  protected B: number = SHA224_IV[1] | 0;\n  protected C: number = SHA224_IV[2] | 0;\n  protected D: number = SHA224_IV[3] | 0;\n  protected E: number = SHA224_IV[4] | 0;\n  protected F: number = SHA224_IV[5] | 0;\n  protected G: number = SHA224_IV[6] | 0;\n  protected H: number = SHA224_IV[7] | 0;\n  constructor() {\n    super(28);\n  }\n}\n\n// SHA2-512 is slower than sha256 in js because u64 operations are slow.\n\n// Round contants\n// First 32 bits of the fractional parts of the cube roots of the first 80 primes 2..409\n// prettier-ignore\nconst K512 = /* @__PURE__ */ (() => u64.split([\n  '0x428a2f98d728ae22', '0x7137449123ef65cd', '0xb5c0fbcfec4d3b2f', '0xe9b5dba58189dbbc',\n  '0x3956c25bf348b538', '0x59f111f1b605d019', '0x923f82a4af194f9b', '0xab1c5ed5da6d8118',\n  '0xd807aa98a3030242', '0x12835b0145706fbe', '0x243185be4ee4b28c', '0x550c7dc3d5ffb4e2',\n  '0x72be5d74f27b896f', '0x80deb1fe3b1696b1', '0x9bdc06a725c71235', '0xc19bf174cf692694',\n  '0xe49b69c19ef14ad2', '0xefbe4786384f25e3', '0x0fc19dc68b8cd5b5', '0x240ca1cc77ac9c65',\n  '0x2de92c6f592b0275', '0x4a7484aa6ea6e483', '0x5cb0a9dcbd41fbd4', '0x76f988da831153b5',\n  '0x983e5152ee66dfab', '0xa831c66d2db43210', '0xb00327c898fb213f', '0xbf597fc7beef0ee4',\n  '0xc6e00bf33da88fc2', '0xd5a79147930aa725', '0x06ca6351e003826f', '0x142929670a0e6e70',\n  '0x27b70a8546d22ffc', '0x2e1b21385c26c926', '0x4d2c6dfc5ac42aed', '0x53380d139d95b3df',\n  '0x650a73548baf63de', '0x766a0abb3c77b2a8', '0x81c2c92e47edaee6', '0x92722c851482353b',\n  '0xa2bfe8a14cf10364', '0xa81a664bbc423001', '0xc24b8b70d0f89791', '0xc76c51a30654be30',\n  '0xd192e819d6ef5218', '0xd69906245565a910', '0xf40e35855771202a', '0x106aa07032bbd1b8',\n  '0x19a4c116b8d2d0c8', '0x1e376c085141ab53', '0x2748774cdf8eeb99', '0x34b0bcb5e19b48a8',\n  '0x391c0cb3c5c95a63', '0x4ed8aa4ae3418acb', '0x5b9cca4f7763e373', '0x682e6ff3d6b2b8a3',\n  '0x748f82ee5defb2fc', '0x78a5636f43172f60', '0x84c87814a1f0ab72', '0x8cc702081a6439ec',\n  '0x90befffa23631e28', '0xa4506cebde82bde9', '0xbef9a3f7b2c67915', '0xc67178f2e372532b',\n  '0xca273eceea26619c', '0xd186b8c721c0c207', '0xeada7dd6cde0eb1e', '0xf57d4f7fee6ed178',\n  '0x06f067aa72176fba', '0x0a637dc5a2c898a6', '0x113f9804bef90dae', '0x1b710b35131c471b',\n  '0x28db77f523047d84', '0x32caab7b40c72493', '0x3c9ebe0a15c9bebc', '0x431d67c49c100d4c',\n  '0x4cc5d4becb3e42b6', '0x597f299cfc657e2a', '0x5fcb6fab3ad6faec', '0x6c44198c4a475817'\n].map(n => BigInt(n))))();\nconst SHA512_Kh = /* @__PURE__ */ (() => K512[0])();\nconst SHA512_Kl = /* @__PURE__ */ (() => K512[1])();\n\n// Reusable temporary buffers\nconst SHA512_W_H = /* @__PURE__ */ new Uint32Array(80);\nconst SHA512_W_L = /* @__PURE__ */ new Uint32Array(80);\n\nexport class SHA512 extends HashMD<SHA512> {\n  // We cannot use array here since array allows indexing by variable\n  // which means optimizer/compiler cannot use registers.\n  // h -- high 32 bits, l -- low 32 bits\n  protected Ah: number = SHA512_IV[0] | 0;\n  protected Al: number = SHA512_IV[1] | 0;\n  protected Bh: number = SHA512_IV[2] | 0;\n  protected Bl: number = SHA512_IV[3] | 0;\n  protected Ch: number = SHA512_IV[4] | 0;\n  protected Cl: number = SHA512_IV[5] | 0;\n  protected Dh: number = SHA512_IV[6] | 0;\n  protected Dl: number = SHA512_IV[7] | 0;\n  protected Eh: number = SHA512_IV[8] | 0;\n  protected El: number = SHA512_IV[9] | 0;\n  protected Fh: number = SHA512_IV[10] | 0;\n  protected Fl: number = SHA512_IV[11] | 0;\n  protected Gh: number = SHA512_IV[12] | 0;\n  protected Gl: number = SHA512_IV[13] | 0;\n  protected Hh: number = SHA512_IV[14] | 0;\n  protected Hl: number = SHA512_IV[15] | 0;\n\n  constructor(outputLen: number = 64) {\n    super(128, outputLen, 16, false);\n  }\n  // prettier-ignore\n  protected get(): [\n    number, number, number, number, number, number, number, number,\n    number, number, number, number, number, number, number, number\n  ] {\n    const { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;\n    return [Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl];\n  }\n  // prettier-ignore\n  protected set(\n    Ah: number, Al: number, Bh: number, Bl: number, Ch: number, Cl: number, Dh: number, Dl: number,\n    Eh: number, El: number, Fh: number, Fl: number, Gh: number, Gl: number, Hh: number, Hl: number\n  ): void {\n    this.Ah = Ah | 0;\n    this.Al = Al | 0;\n    this.Bh = Bh | 0;\n    this.Bl = Bl | 0;\n    this.Ch = Ch | 0;\n    this.Cl = Cl | 0;\n    this.Dh = Dh | 0;\n    this.Dl = Dl | 0;\n    this.Eh = Eh | 0;\n    this.El = El | 0;\n    this.Fh = Fh | 0;\n    this.Fl = Fl | 0;\n    this.Gh = Gh | 0;\n    this.Gl = Gl | 0;\n    this.Hh = Hh | 0;\n    this.Hl = Hl | 0;\n  }\n  protected process(view: DataView, offset: number): void {\n    // Extend the first 16 words into the remaining 64 words w[16..79] of the message schedule array\n    for (let i = 0; i < 16; i++, offset += 4) {\n      SHA512_W_H[i] = view.getUint32(offset);\n      SHA512_W_L[i] = view.getUint32((offset += 4));\n    }\n    for (let i = 16; i < 80; i++) {\n      // s0 := (w[i-15] rightrotate 1) xor (w[i-15] rightrotate 8) xor (w[i-15] rightshift 7)\n      const W15h = SHA512_W_H[i - 15] | 0;\n      const W15l = SHA512_W_L[i - 15] | 0;\n      const s0h = u64.rotrSH(W15h, W15l, 1) ^ u64.rotrSH(W15h, W15l, 8) ^ u64.shrSH(W15h, W15l, 7);\n      const s0l = u64.rotrSL(W15h, W15l, 1) ^ u64.rotrSL(W15h, W15l, 8) ^ u64.shrSL(W15h, W15l, 7);\n      // s1 := (w[i-2] rightrotate 19) xor (w[i-2] rightrotate 61) xor (w[i-2] rightshift 6)\n      const W2h = SHA512_W_H[i - 2] | 0;\n      const W2l = SHA512_W_L[i - 2] | 0;\n      const s1h = u64.rotrSH(W2h, W2l, 19) ^ u64.rotrBH(W2h, W2l, 61) ^ u64.shrSH(W2h, W2l, 6);\n      const s1l = u64.rotrSL(W2h, W2l, 19) ^ u64.rotrBL(W2h, W2l, 61) ^ u64.shrSL(W2h, W2l, 6);\n      // SHA256_W[i] = s0 + s1 + SHA256_W[i - 7] + SHA256_W[i - 16];\n      const SUMl = u64.add4L(s0l, s1l, SHA512_W_L[i - 7], SHA512_W_L[i - 16]);\n      const SUMh = u64.add4H(SUMl, s0h, s1h, SHA512_W_H[i - 7], SHA512_W_H[i - 16]);\n      SHA512_W_H[i] = SUMh | 0;\n      SHA512_W_L[i] = SUMl | 0;\n    }\n    let { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;\n    // Compression function main loop, 80 rounds\n    for (let i = 0; i < 80; i++) {\n      // S1 := (e rightrotate 14) xor (e rightrotate 18) xor (e rightrotate 41)\n      const sigma1h = u64.rotrSH(Eh, El, 14) ^ u64.rotrSH(Eh, El, 18) ^ u64.rotrBH(Eh, El, 41);\n      const sigma1l = u64.rotrSL(Eh, El, 14) ^ u64.rotrSL(Eh, El, 18) ^ u64.rotrBL(Eh, El, 41);\n      //const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;\n      const CHIh = (Eh & Fh) ^ (~Eh & Gh);\n      const CHIl = (El & Fl) ^ (~El & Gl);\n      // T1 = H + sigma1 + Chi(E, F, G) + SHA512_K[i] + SHA512_W[i]\n      // prettier-ignore\n      const T1ll = u64.add5L(Hl, sigma1l, CHIl, SHA512_Kl[i], SHA512_W_L[i]);\n      const T1h = u64.add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh[i], SHA512_W_H[i]);\n      const T1l = T1ll | 0;\n      // S0 := (a rightrotate 28) xor (a rightrotate 34) xor (a rightrotate 39)\n      const sigma0h = u64.rotrSH(Ah, Al, 28) ^ u64.rotrBH(Ah, Al, 34) ^ u64.rotrBH(Ah, Al, 39);\n      const sigma0l = u64.rotrSL(Ah, Al, 28) ^ u64.rotrBL(Ah, Al, 34) ^ u64.rotrBL(Ah, Al, 39);\n      const MAJh = (Ah & Bh) ^ (Ah & Ch) ^ (Bh & Ch);\n      const MAJl = (Al & Bl) ^ (Al & Cl) ^ (Bl & Cl);\n      Hh = Gh | 0;\n      Hl = Gl | 0;\n      Gh = Fh | 0;\n      Gl = Fl | 0;\n      Fh = Eh | 0;\n      Fl = El | 0;\n      ({ h: Eh, l: El } = u64.add(Dh | 0, Dl | 0, T1h | 0, T1l | 0));\n      Dh = Ch | 0;\n      Dl = Cl | 0;\n      Ch = Bh | 0;\n      Cl = Bl | 0;\n      Bh = Ah | 0;\n      Bl = Al | 0;\n      const All = u64.add3L(T1l, sigma0l, MAJl);\n      Ah = u64.add3H(All, T1h, sigma0h, MAJh);\n      Al = All | 0;\n    }\n    // Add the compressed chunk to the current hash value\n    ({ h: Ah, l: Al } = u64.add(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));\n    ({ h: Bh, l: Bl } = u64.add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0));\n    ({ h: Ch, l: Cl } = u64.add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));\n    ({ h: Dh, l: Dl } = u64.add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));\n    ({ h: Eh, l: El } = u64.add(this.Eh | 0, this.El | 0, Eh | 0, El | 0));\n    ({ h: Fh, l: Fl } = u64.add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));\n    ({ h: Gh, l: Gl } = u64.add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));\n    ({ h: Hh, l: Hl } = u64.add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));\n    this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);\n  }\n  protected roundClean(): void {\n    clean(SHA512_W_H, SHA512_W_L);\n  }\n  destroy(): void {\n    clean(this.buffer);\n    this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);\n  }\n}\n\nexport class SHA384 extends SHA512 {\n  protected Ah: number = SHA384_IV[0] | 0;\n  protected Al: number = SHA384_IV[1] | 0;\n  protected Bh: number = SHA384_IV[2] | 0;\n  protected Bl: number = SHA384_IV[3] | 0;\n  protected Ch: number = SHA384_IV[4] | 0;\n  protected Cl: number = SHA384_IV[5] | 0;\n  protected Dh: number = SHA384_IV[6] | 0;\n  protected Dl: number = SHA384_IV[7] | 0;\n  protected Eh: number = SHA384_IV[8] | 0;\n  protected El: number = SHA384_IV[9] | 0;\n  protected Fh: number = SHA384_IV[10] | 0;\n  protected Fl: number = SHA384_IV[11] | 0;\n  protected Gh: number = SHA384_IV[12] | 0;\n  protected Gl: number = SHA384_IV[13] | 0;\n  protected Hh: number = SHA384_IV[14] | 0;\n  protected Hl: number = SHA384_IV[15] | 0;\n\n  constructor() {\n    super(48);\n  }\n}\n\n/**\n * Truncated SHA512/256 and SHA512/224.\n * SHA512_IV is XORed with 0xa5a5a5a5a5a5a5a5, then used as \"intermediary\" IV of SHA512/t.\n * Then t hashes string to produce result IV.\n * See `test/misc/sha2-gen-iv.js`.\n */\n\n/** SHA512/224 IV */\nconst T224_IV = /* @__PURE__ */ Uint32Array.from([\n  0x8c3d37c8, 0x19544da2, 0x73e19966, 0x89dcd4d6, 0x1dfab7ae, 0x32ff9c82, 0x679dd514, 0x582f9fcf,\n  0x0f6d2b69, 0x7bd44da8, 0x77e36f73, 0x04c48942, 0x3f9d85a8, 0x6a1d36c8, 0x1112e6ad, 0x91d692a1,\n]);\n\n/** SHA512/256 IV */\nconst T256_IV = /* @__PURE__ */ Uint32Array.from([\n  0x22312194, 0xfc2bf72c, 0x9f555fa3, 0xc84c64c2, 0x2393b86b, 0x6f53b151, 0x96387719, 0x5940eabd,\n  0x96283ee2, 0xa88effe3, 0xbe5e1e25, 0x53863992, 0x2b0199fc, 0x2c85b8aa, 0x0eb72ddc, 0x81c52ca2,\n]);\n\nexport class SHA512_224 extends SHA512 {\n  protected Ah: number = T224_IV[0] | 0;\n  protected Al: number = T224_IV[1] | 0;\n  protected Bh: number = T224_IV[2] | 0;\n  protected Bl: number = T224_IV[3] | 0;\n  protected Ch: number = T224_IV[4] | 0;\n  protected Cl: number = T224_IV[5] | 0;\n  protected Dh: number = T224_IV[6] | 0;\n  protected Dl: number = T224_IV[7] | 0;\n  protected Eh: number = T224_IV[8] | 0;\n  protected El: number = T224_IV[9] | 0;\n  protected Fh: number = T224_IV[10] | 0;\n  protected Fl: number = T224_IV[11] | 0;\n  protected Gh: number = T224_IV[12] | 0;\n  protected Gl: number = T224_IV[13] | 0;\n  protected Hh: number = T224_IV[14] | 0;\n  protected Hl: number = T224_IV[15] | 0;\n\n  constructor() {\n    super(28);\n  }\n}\n\nexport class SHA512_256 extends SHA512 {\n  protected Ah: number = T256_IV[0] | 0;\n  protected Al: number = T256_IV[1] | 0;\n  protected Bh: number = T256_IV[2] | 0;\n  protected Bl: number = T256_IV[3] | 0;\n  protected Ch: number = T256_IV[4] | 0;\n  protected Cl: number = T256_IV[5] | 0;\n  protected Dh: number = T256_IV[6] | 0;\n  protected Dl: number = T256_IV[7] | 0;\n  protected Eh: number = T256_IV[8] | 0;\n  protected El: number = T256_IV[9] | 0;\n  protected Fh: number = T256_IV[10] | 0;\n  protected Fl: number = T256_IV[11] | 0;\n  protected Gh: number = T256_IV[12] | 0;\n  protected Gl: number = T256_IV[13] | 0;\n  protected Hh: number = T256_IV[14] | 0;\n  protected Hl: number = T256_IV[15] | 0;\n\n  constructor() {\n    super(32);\n  }\n}\n\n/**\n * SHA2-256 hash function from RFC 4634.\n *\n * It is the fastest JS hash, even faster than Blake3.\n * To break sha256 using birthday attack, attackers need to try 2^128 hashes.\n * BTC network is doing 2^70 hashes/sec (2^95 hashes/year) as per 2025.\n */\nexport const sha256: CHash = /* @__PURE__ */ createHasher(() => new SHA256());\n/** SHA2-224 hash function from RFC 4634 */\nexport const sha224: CHash = /* @__PURE__ */ createHasher(() => new SHA224());\n\n/** SHA2-512 hash function from RFC 4634. */\nexport const sha512: CHash = /* @__PURE__ */ createHasher(() => new SHA512());\n/** SHA2-384 hash function from RFC 4634. */\nexport const sha384: CHash = /* @__PURE__ */ createHasher(() => new SHA384());\n\n/**\n * SHA2-512/256 \"truncated\" hash function, with improved resistance to length extension attacks.\n * See the paper on [truncated SHA512](https://eprint.iacr.org/2010/548.pdf).\n */\nexport const sha512_256: CHash = /* @__PURE__ */ createHasher(() => new SHA512_256());\n/**\n * SHA2-512/224 \"truncated\" hash function, with improved resistance to length extension attacks.\n * See the paper on [truncated SHA512](https://eprint.iacr.org/2010/548.pdf).\n */\nexport const sha512_224: CHash = /* @__PURE__ */ createHasher(() => new SHA512_224());\n", "/**\n * SHA2-256 a.k.a. sha256. In JS, it is the fastest hash, even faster than Blake3.\n *\n * To break sha256 using birthday attack, attackers need to try 2^128 hashes.\n * BTC network is doing 2^70 hashes/sec (2^95 hashes/year) as per 2025.\n *\n * Check out [FIPS 180-4](https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf).\n * @module\n * @deprecated\n */\nimport {\n  SHA224 as SHA224n,\n  sha224 as sha224n,\n  SHA256 as SHA256n,\n  sha256 as sha256n,\n} from './sha2.ts';\n/** @deprecated Use import from `noble/hashes/sha2` module */\nexport const SHA256: typeof SHA256n = SHA256n;\n/** @deprecated Use import from `noble/hashes/sha2` module */\nexport const sha256: typeof sha256n = sha256n;\n/** @deprecated Use import from `noble/hashes/sha2` module */\nexport const SHA224: typeof SHA224n = SHA224n;\n/** @deprecated Use import from `noble/hashes/sha2` module */\nexport const sha224: typeof sha224n = sha224n;\n", "/**\n * kb-noble.js - Noble cryptography implementations for Keybearer v2\n *\n * This module provides modern cryptographic primitives using @noble/ciphers and @noble/hashes\n * to replace the deprecated SJCL library.\n */\n\nimport { chacha20poly1305 } from '@noble/ciphers/chacha';\nimport { pbkdf2 } from '@noble/hashes/pbkdf2';\nimport { sha256 } from '@noble/hashes/sha256';\n\n/**\n * Generate cryptographically secure random bytes using Web Crypto API\n * Replaces: sjcl.random.randomWords(n)\n */\nexport function getRandomBytes(count) {\n  const bytes = new Uint8Array(count);\n  crypto.getRandomValues(bytes);\n  return bytes;\n}\n\n/**\n * Generate random words (32-bit integers) for compatibility\n * Used for IV generation and similar purposes\n */\nexport function getRandomWords(count) {\n  const bytes = getRandomBytes(count * 4);\n  const words = new Uint32Array(bytes.buffer);\n  return Array.from(words);\n}\n\n/**\n * Derive encryption key from password using PBKDF2-SHA256\n * Replaces: sjcl.misc.pbkdf2()\n *\n * @param {string} password - Password string\n * @param {Uint8Array} salt - Salt bytes\n * @param {number} iterations - PBKDF2 iteration count\n * @param {number} keyLength - Key length in bytes (default 32 for 256-bit)\n * @returns {Uint8Array} - Derived key\n */\nexport function deriveKeyFromPassword(password, salt, iterations, keyLength = 32) {\n  const passwordBytes = new TextEncoder().encode(password);\n  return pbkdf2(sha256, passwordBytes, salt, {\n    c: iterations,\n    dkLen: keyLength\n  });\n}\n\n/**\n * Encrypt plaintext using ChaCha20-Poly1305\n * Replaces: sjcl.mode.ccm.encrypt() and sjcl.mode.ocb2.encrypt()\n *\n * @param {Uint8Array} key - 256-bit encryption key\n * @param {Uint8Array} plaintext - Data to encrypt\n * @param {Uint8Array} nonce - 96-bit (12-byte) nonce (optional, generated if not provided)\n * @param {Uint8Array} aad - Additional authenticated data (optional)\n * @returns {Object} - {ciphertext: Uint8Array, nonce: Uint8Array}\n */\nexport function encryptChaCha20Poly1305(key, plaintext, nonce = null, aad = new Uint8Array(0)) {\n  if (!nonce) {\n    nonce = getRandomBytes(12); // ChaCha20-Poly1305 uses 96-bit nonce\n  }\n\n  const cipher = chacha20poly1305(key, nonce);\n  const ciphertext = cipher.encrypt(plaintext, aad);\n\n  return { ciphertext, nonce };\n}\n\n/**\n * Decrypt ciphertext using ChaCha20-Poly1305\n *\n * @param {Uint8Array} key - 256-bit decryption key\n * @param {Uint8Array} ciphertext - Data to decrypt (includes auth tag)\n * @param {Uint8Array} nonce - 96-bit (12-byte) nonce\n * @param {Uint8Array} aad - Additional authenticated data (optional)\n * @returns {Uint8Array} - Decrypted plaintext\n * @throws {Error} - If authentication fails\n */\nexport function decryptChaCha20Poly1305(key, ciphertext, nonce, aad = new Uint8Array(0)) {\n  const cipher = chacha20poly1305(key, nonce);\n  return cipher.decrypt(ciphertext, aad);\n}\n\n/**\n * Encode Uint8Array to base64 string\n * Replaces: sjcl.codec.base64.fromBits()\n */\nexport function encodeBase64(uint8array) {\n  const binaryString = Array.from(uint8array, byte => String.fromCharCode(byte)).join('');\n  return btoa(binaryString);\n}\n\n/**\n * Decode base64 string to Uint8Array\n * Replaces: sjcl.codec.base64.toBits()\n */\nexport function decodeBase64(base64str) {\n  const binaryString = atob(base64str);\n  return Uint8Array.from(binaryString, char => char.charCodeAt(0));\n}\n\n/**\n * Generate random integers in range [0, max)\n * Replaces: keybearer.randto() but uses secure random source\n *\n * @param {number} max - Upper bound (exclusive)\n * @param {number} count - Number of random integers to generate\n * @returns {Array<number>} - Array of random integers\n */\nexport function randomIntegers(max, count) {\n  const result = [];\n  const randomBytes = getRandomBytes(count * 4); // 4 bytes per integer\n  const randomInts = new Uint32Array(randomBytes.buffer);\n\n  // Use rejection sampling to avoid modulo bias\n  const maxValid = Math.floor(0xFFFFFFFF / max) * max;\n\n  for (let i = 0; i < count; i++) {\n    let value = randomInts[i];\n    // Regenerate if value would cause bias\n    while (value >= maxValid) {\n      const newBytes = getRandomBytes(4);\n      value = new Uint32Array(newBytes.buffer)[0];\n    }\n    result.push(value % max);\n  }\n\n  return result;\n}\n", "/**\n * kb-legacy.js - Minimal SJCL wrapper for legacy CCM/OCB2 decryption\n *\n * This module provides ONLY the decryption functionality needed for backward compatibility\n * with existing .kbr.json files that use AES-CCM or AES-OCB2.\n *\n * IMPORTANT: This code is NOT used for new encryptions - only for decrypting legacy files.\n */\n\n/**\n * Convert SJCL bitArray to Uint8Array\n */\nexport function bitArrayToBytes(bitArray) {\n  const out = [];\n  const bl = sjcl.bitArray.bitLength(bitArray);\n  let tmp;\n\n  for (let i = 0; i < bl / 8; i++) {\n    if ((i & 3) === 0) {\n      tmp = bitArray[i / 4];\n    }\n    out.push(tmp >>> 24);\n    tmp <<= 8;\n  }\n\n  return new Uint8Array(out);\n}\n\n/**\n * Convert Uint8Array to SJCL bitArray\n */\nexport function bytesToBitArray(bytes) {\n  const out = [];\n  let tmp = 0;\n\n  for (let i = 0; i < bytes.length; i++) {\n    tmp = (tmp << 8) | bytes[i];\n    if ((i & 3) === 3) {\n      out.push(tmp);\n      tmp = 0;\n    }\n  }\n\n  if (bytes.length & 3) {\n    out.push(sjcl.bitArray.partial(8 * (bytes.length & 3), tmp));\n  }\n\n  return out;\n}\n\n/**\n * Decrypt using legacy SJCL (CCM or OCB2 mode)\n *\n * @param {Object} cipherobj - Legacy cipher object with SJCL bitArrays\n * @param {Array} key - SJCL bitArray key\n * @returns {Uint8Array} - Decrypted plaintext as Uint8Array\n */\nexport function decryptLegacy(cipherobj, key) {\n  // Use SJCL for legacy decryption\n  const prp = new sjcl.cipher[cipherobj.cipher](key);\n  const plaintext = sjcl.mode[cipherobj.mode].decrypt(\n    prp,\n    cipherobj.ct,\n    cipherobj.iv,\n    cipherobj.adata,\n    cipherobj.ts\n  );\n\n  // Convert bitArray result to Uint8Array\n  return bitArrayToBytes(plaintext);\n}\n\n/**\n * Decrypt master key using legacy SJCL\n *\n * @param {Object} cipherobj - Legacy cipher object\n * @param {Array} key - SJCL bitArray key\n * @param {Object} keyiv - {key: bitArray, iv: bitArray}\n * @returns {Array|null} - Decrypted master key as SJCL bitArray, or null if failed\n */\nexport function decryptKeyLegacy(cipherobj, key, keyiv) {\n  try {\n    const prp = new sjcl.cipher[cipherobj.cipher](key);\n    const master = sjcl.mode[cipherobj.mode].decrypt(\n      prp,\n      keyiv.key,\n      keyiv.iv,\n      cipherobj.adata,\n      cipherobj.ts\n    );\n    return master;\n  } catch (err) {\n    return null;\n  }\n}\n\n/**\n * Derive key using legacy SJCL PBKDF2\n * (kept for consistency with legacy files, though Noble's PBKDF2 should produce same output)\n *\n * @param {string} password - Password string\n * @param {Array} salt - SJCL bitArray salt\n * @param {number} iterations - PBKDF2 iteration count\n * @param {number} keyBits - Key length in bits\n * @returns {Array} - SJCL bitArray key\n */\nexport function deriveKeyLegacy(password, salt, iterations, keyBits) {\n  return sjcl.misc.pbkdf2(password, salt, iterations, keyBits);\n}\n\n/**\n * Check if cipher object is legacy format (v1 or missing version)\n */\nexport function isLegacyFormat(cipherobj) {\n  // Legacy formats:\n  // 1. No version field (original format)\n  // 2. v: 1\n  // 3. mode: 'ccm' or 'ocb2'\n  return (\n    !cipherobj.v ||\n    cipherobj.v === 1 ||\n    cipherobj.mode === 'ccm' ||\n    cipherobj.mode === 'ocb2'\n  );\n}\n"],
  "mappings": "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",
  "names": ["isLE", "isAligned32", "isBytes", "anumber", "abytes", "aexists", "aoutput", "clean", "createView", "utf8ToBytes", "toBytes", "utf8ToBytes", "abytes", "checkOpts", "Hash", "toBytes", "Hash", "toBytes", "clean", "aexists", "abytes", "checkOpts", "anumber", "clean", "createView", "setBigUint64", "isLE", "Hash", "createView", "aexists", "toBytes", "abytes", "aoutput", "clean", "clean", "sha256", "sha256", "passwords"]
}
